Overview | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Overview
Version: SDK V4 (latest)
On this page
Overview
The Biconomy SDK is an Account Abstraction toolkit that enables the simplest UX on your dApp, wallet, or appchain.
Built on top of
ERC 4337
, we offer a full-stack solution for tapping into the power of our Smart Accounts Platform, Paymasters, and Bundlers.
Introduction to Account Abstraction
Account Abstraction aims to enhance user experience by making user accounts more flexible and functional. Instead of using an Externally Owned Account, a Smart Contract can act as your account, powered by code instead of the Elliptic Curve Digital Signature Algorithm (ECDSA).
UserOp
​
A userOperation or a userOp is a data structure that describes a transaction to be sent on behalf of a user. It is not an actual Blockchain Transaction but has all the necessary fields to become one. These are fields like “sender,” “to,” “calldata,” “nonce,” and more. You can find the userOp structure
here
.
Entry Point Contract
​
The
Entry Point contract
is the singleton smart contract, the core of the Account Abstraction Flow. This singleton contract is used as an entry point to execute bundles of userOps. Refer to this
blog series
for a comprehensive understanding of the Entry Point.
Smart Account
​
This smart contract acts as a user wallet where all user assets are stored. You can program it to validate transactions before executing them. Unlike a traditional wallet, the Smart Account cannot initiate a transaction independently and will need a signer to help it do so.
Bundler
​
The Bundler collects, bundles, and submits userOps to an EVM network. One can make a JSON RPC call to a bundler client to have a userOp added to an ERC 4337 mempool.
Paymaster
​
The Paymaster is a smart contract that acts as a gas tank and is used to sponsor transactions where the dApp or another third party pays the transaction fee on behalf of the user. The userOp contains a field for adding data about a Paymaster and if it should sponsor the userOp when pushed on-chain to become a transaction.
A smart account sends a userOp to execute a transaction. Bundlers then watch the mempool for userOps and send them on-chain by calling the Entry Point contract.
Now, you have a basic understanding of the ERC 4337 flow for account abstraction.
Smart Accounts Platform
​
The Biconomy's Modular Smart Account is an ERC 4337-compliant solution that works with any Paymaster and Bundler service. Biconomy Smart Accounts are signer agnostic, which means you can use any authorization package as long as a signer is passed to our SDK during Smart Account creation. Explore different methods for creating Smart Accounts
here
.
Modules
​
Modular architecture enables developers to easily & securely plug-in programmable modules to extend smart account capabilities. These modules leverage the power of Account Abstraction to allow for custom validation schemes and execution environments. As a developer, this allows you to build additional modules while leveraging existing ones like
session keys
,
multi-chain validation
, passkeys, and beyond.
If you want to start diving into Smart Accounts you can begin
here
. For those, who are already familiar with Smart Accounts and prefer to start with modules, you can check out
here
or follow this step-by-step
tutorial
on how to build a dApp that utilizes session key modules.
View the audit reports for smart accounts and Modules
here
.
Bundler
​
The Bundler is a service that tracks userOps that exist in an alternative mem pool and as the name suggests, bundles them together to send to an Entry Point Contract for eventual execution onchain.
This is the final piece of the flow where after constructing your userOp and then potentially signing it with data from a paymaster, you send the userOp on-chain to be handled and executed as a transaction on the EVM. You can start using our Bundlers right now in your dApps. Each of our
tutorials
will walk you through how to use them in different scenarios.
View the list of supported networks by Biconomy bundler
here
.
If you are looking to integrate account abstraction using APIs, checkout the
bundler APIs
and
tutorials
.
Paymaster
​
Biconomy's paymaster service enables Dapps to sponsor transactions and, also allows users to use ERC-20 tokens as payment for gas. Log in to the
Biconomy dashboard
to get the paymaster URL and switch modes between our sponsorship and token Paymaster. Make use of different
Spending limits
to customize the paymaster usage.
Sponsorship Paymaster
​
Enabling the Sponsored mode facilitates gasless transactions, eliminating the necessity for users to have native tokens to cover gas fees. Learn how to set up your paymaster
here
.
Token Paymaster
​
Switching your Paymaster mode to ERC20 enables users to pay gas fees with ERC20 tokens across networks See the latest supported networks tokens
here
.
Learn how to utilize either of these Paymasters by checking out our How To Guide on
Executing transactions
Next:
Checkout the
quickstart
guide to start the integration.
Next
Quickstart
UserOp
Entry Point Contract
Smart Account
Bundler
Paymaster
Smart Accounts Platform
Modules
Bundler
Paymaster
Sponsorship Paymaster
Token Paymaster
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Page Not Found
We could not find what you were looking for.
Please contact the owner of the site that linked you to the original URL and let them know their link is broken.
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Page Not Found
We could not find what you were looking for.
Please contact the owner of the site that linked you to the original URL and let them know their link is broken.
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Supported Networks | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Supported Networks & Tokens
Version: SDK V4 (latest)
On this page
Supported Networks
This is the list of networks supported by our Bundlers & Paymaster.
Network
Testnet
Mainnet
Ethereum
✅
✅
Polygon
✅
✅
BSC
✅
✅
Polygon zkEVM
✅
✅
Arbitrum One
✅
✅
Arbitrum Nova
✅
✅
Optimism
✅ (Sepolia)
✅
Avalanche
✅
✅
Base
✅
✅
Linea
✅
✅
Chiliz
✅
✅
Astar
✅
✅
opBNB
✅
✅
Manta
✅
✅
Core
✅
✅
Combo
✅
✅
Mantle
✅ (Sepolia)
✅
Blast
✅
✅
Zeroone
✅
✅
Scroll
✅
✅
Bera
✅
Zetachain
✅
✅
Gold (L3 on Base)
✅
Degenchain
✅
Olive
✅
Polygon zkEVM Cardona
✅
Gnosis
✅
✅
X Layer
✅
✅
Supported Tokens
​
Our Paymaster not only allows you to sponsor transactions for your users but also allows users to pay for transactions using ERC20 tokens. Below are the supported tokens list grouped by chain.
Please note that we will be reviewing DEX activity on each network to determine additional ERC20 token support on an ongoing basis.
Loading...
Previous
FAQ
Supported Tokens
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

FAQ | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
FAQ
Version: SDK V4 (latest)
On this page
FAQ
Smart accounts and SDK
​
Will I get the same smart account address on all chains?
Yes, you will get the same address on all chains as long as the owner's address is the same.
How can I create another smart account using the same EOA on the same chain?
you can pass the
index
in the config while creating the account as mentioned in the createSmartAccountClient
method
. First smart account gets created with index 0 by default.
Where can I find more examples of SDK integrations?
https://github.com/bcnmy/sdk-examples
How can I increase the timeout in the waitForTransactionHash function?
Initialize the bundler with updated configuration, to increase the timeout (milliseconds).
import
{
createSmartAccountClient
,
createBundler
}
from
"@biconomy/account"
;
const
biconomySmartAccount
=
await
createSmartAccountClient
(
{
signer
,
bundler
:
await
createBundler
(
{
bundlerUrl
:
"bundler url"
,
userOpReceiptMaxDurationIntervals
:
{
80002
:
60000
}
,
}
)
,
}
)
;
Which social login methods are supported?
Explore services such as Web3Auth, Particle Network, Magic.link, or Lit Protocol to link a user's social identity with a cryptographic key. This key can then serve as the owner of the Smart Account. Be sure to check out various
signers
integrations for this purpose.
How do I enable session keys for users?
Utilize the session key validation
module
.
How to enable debug mode in SDK to log more?
Set following env flag to true before running the app.
export BICONOMY_SDK_DEBUG=true
What are 2D Nonces?
In account abstraction, user operations use two-dimensional (2D) nonces. This is different from EOAs (Externally Owned Accounts), which currently use one-dimensional nonces. For EOAs, every transaction increases the nonce by 1, following a sequential order.
A User Operation is similar in that it can generate sequential nonces (when nonceKey is 0), but it also has the ability to use 2D nonces (when nonceKey > 0), allowing for parallel user operations.
Here's what happens under the hood of the getNonce() method:
return
nonceSequenceNumber
[
sender
]
[
key
]
|
(
uint256
(
key
)
<<
64
)
The current key sequence is combined with a left-shifted value of the same key. The end result is a single number representing all possible 2D nonces.
What are Parallel User Ops?
Parallel user ops are user operations that are not dependent on each other and can be executed simultaneously, without waiting for any previous user operation to be executed on-chain.
Let's take an example of a user executing some actions on a Dapp. The Dapp wants to batch transactions together to provide a better user experience (UX).
Bob
swaps
1
ETH
for
4000
USDC
Bob
swaps
4000
USDC
for
7000
BICO
Bob
buys
1
NFT
for
100
USDC
Transactions 1 and 2 will be batched into one user operation and will be executed in order, while transaction 3 will be added in another user operation.
The second user operation can be sent after the first one is done, using a sequential nonce, this means it will wait for the first user operation to be settled on-chain. However, we can do better. By using 2D nonces, we can send both user ops at the same time. While Bob is swapping ETH for USDC and USDC for BICO, he can also buy that cool NFT simultaneously.
Here is a tutorial on how to send parallel user ops with the Biconomy SDK:
https://docs.biconomy.io/tutorials/parallelUserOps
Bundler & Paymaster
​
Is the bundler URL the same for all chains?
Yes, for testnets same
bundler URL
can be used, just change the chainId. For mainnet you can reach out to
us
.
How can I sign the userOp manually?
To sign the userOp manually, first calculate the userOpHash and then sign it using the same signer, the account is created with. you can find more details
here
.
Can I just use Biconomy’s bundler with another smart account implementation?
Yes, Biconomy's bundler seamlessly integrates with other smart account providers. As long as the user operation remains valid and complies with ERC 4337 specifications, the integration is possible.
Which ERC20 tokens are supported by the biconomy paymaster? How can I add support for a custom ERC20 token?
You can check out the list of supported networks
here
. You can reach out to us here for custom token requirements.
Can I use other paymaster with Biconomy SDK?
Yes, you can. It completely depends on how the
paymasterAndData
is parsed in the paymaster. The only restriction is that it should first encode the paymaster address after that encoding can be anything till the time decoding is consistent. Bundler does not care about the paymasterAndData.
Can I fund the gasTank programmatically?
You can programmatically deposit funds using the paymasterContract
depositFor
function by passing the
amount
and
paymasterId
which is the EOA address. For instance, you can invoke the following
function
on the Polygon chain. Check out
this
script for the same.
Are there APIs to create my own dashboard?
Yes, you can utilize the
dashboard APIs
to create a paymaster, change policies, and even get the transaction's data.
Previous
Audits
Next
Supported Networks & Tokens
Smart accounts and SDK
Bundler & Paymaster
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Audits | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Audits
Version: SDK V4 (latest)
On this page
Audits
Smart Accounts and Modules
​
Title
Auditor
Link
Biconomy Smart Account
Zellic
Link to report
Smart Account and Session Keys
Kawach
Link to report
PasskeyRegistry and SessionKey Manager
Zellic
Link to report
Account Recovery Module
Zellic
Link to report
Account Recovery Module
Kawach
Link to report
Batched Session Router module
Zellic
Link to report
Batched Session Router module
Kawach
Link to report
Multichain Validator
Zellic
Link to report
Multichain Validator
Kawach
Link to report
Biconomy Multi Owned ECDSA
Zellic
Link to report
Paymasters
​
Audit Title
Link
Zellic Paymaster
Link to report
Zellic Token Paymaster
Link to report
Previous
Contract Addresses
Next
FAQ
Smart Accounts and Modules
Paymasters
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Contract Addresses | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Contract Addresses
Version: SDK V4 (latest)
On this page
Contract Addresses
info
These contracts are deployed across all supported chains.
Entry points
​
Contract Name
Address
Entry point (chiliz mainnet & testnet)
0x00000061FEfce24A79343c27127435286BB7A4E1
Entry point (all the other chains)
0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789
Smart Account
​
Contract Name
Address
Smart Account Implementation V2
0x0000002512019Dafb59528B82CB92D3c5D2423aC
Smart Account Factory V2
0x000000a56Aaca3e9a4C479ea6b6CD0DbcB6634F5
ECDSA Ownership Module
0x0000001c5b32F37F5beA87BDD5374eB2aC54eA8e
Multichain Validation Module
0x000000824dc138db84FD9109fc154bdad332Aa8E
Batched Session Router Module
0x000008dA71757C0E1D83CE56c823e25Aa49bC058
ABI Session Validation Module
0x000006bC2eCdAe38113929293d241Cf252D91861
Session Key Manager V1
0x000002FbFfedd9B33F4E7156F2DE8D48945E7489
Verifying Paymaster V1
0x000031DD6D9D3A133E663660b959162870D755D4
Verifying Paymaster V1.1.0
0x00000f79b7faf42eebadba19acc07cd08af44789
Token Paymaster
0x00000f7365cA6C59A2C93719ad53d567ed49c14C
Legacy: Smart Account V1
​
Contract Name
Address
Smart Account Implementation V1
0x00006B7e42e01957dA540Dc6a8F7C30c4D816af5
Smart Account Factory V1
0x000000F9eE1842Bb72F6BBDD75E6D3d4e3e9594C
Blast Gold Addresses
​
Contract Name
Address
Points Operator address
0x2cf491602ad22944D9047282aBC00D3e52F56B37
Deployed Smart Contract
0x7f4FB6A17A84aAc3e16BbC0C8d03Ca563aB0c483
info
It is recommended to use Verifying Paymaster V1.1.0 as this includes all features in previous version as well as features such as expirations for paymaster requests.
Previous
Polyfill Errors
Next
Audits
Entry points
Smart Account
Legacy: Smart Account V1
Blast Gold Addresses
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Troubleshooting | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Common Errors
Polyfill Errors
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Troubleshooting
Version: SDK V4 (latest)
Troubleshooting
Troubleshooting errors while working with the Biconomy SDK
📄️
Common Errors
We are sorry to cause any inconvenience while interacting with biconomy SDK. We are trying our best to send meaningful error messages that can help you do quick fixes without interacting with any support channel. Some of the error messages are not in our control as we are using some standard contract ( e.g EntryPoint ) to provider gasless experience. Following are some standard error messages that can help you apply quick fixes and sort the issues.
📄️
Polyfill Errors
With many web3 tools you may run into Polyfill issues with error messages like 'crypto' not found, or 'buffer' not found. These are caused by Node JS Polyfills that are no longer included with Webpack after version 5. You can read more about the full details of this here.
Previous
APIs
Next
Common Errors
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Dashboard | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Version: SDK V4 (latest)
On this page
Dashboard
The Biconomy dashboard is your gateway to accessing our services such as Paymaster, Bundlers, and allows you to retrieve your API keys for usage with our SDK and API. Additionally, this is where you can top up and configure your Paymasters for sponsoring transactions.
info
Please note that this documentation refers to our Account Abstraction SDK solution. If you need information about the EOA gasless dashboard please refer to these
docs
Login
​
The Biconomy Dashboard can be found at
dashboard.biconomy.io/
. Several sign in options are available including Email, Github, and Gitlab.
Paymaster Keys
​
Paymaster keys can be found on the Overview page of the paymasters. You can copy your Paymaster API Key as well as your Paymaster URL as shown below
Bundler URL
​
Our Bundler as a service is coming soon but for now you can use the following URL for your bundler package:
https://bundler.biconomy.io/api/v2/{chain-id-here}/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44
For a Bundler URL on mainnet, please contact
us
.
In the following sections, we will more systematically introduce the following concepts:
📄️
Create a Paymaster
Add Paymaster
📄️
Paymaster Rules
For a paymaster, you can restrict the sponsorship to only specified contracts and methods if needed. If no contract is whitelisted, then paymaster will facilitate all the contract interactions.
📄️
Spending Limits
This feature allows you to set limits to the gas usage. You can define global limits or per-user quotas, specifying either transaction count or total gas consumption.
📄️
Organizations
The organization feature is designed to enhance collaboration and streamline team management within your workspace.
📄️
APIs
Using these APIs allow you to perform various actions without the need to access the dashboard UI manually.
Previous
ABI Session Validation Module
Next
Create a Paymaster
Login
Paymaster Keys
Bundler URL
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Modules | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
Version: SDK V4 (latest)
On this page
Modules
Modular smart accounts (MSA) offer more flexibility than 'static' accounts. Static accounts often need a developer for changes and involve complex proxy upgrades. In contrast, with MSA the functionalities are moved to external contracts called
modules
to increase the speed of feature development. MSA lets users install or uninstall these modules, avoiding the need for entire account redeployment.
Biconomy MSA (Modular Smart Account) has two types of modules:
Validation modules
- These modules define different signature schemes or authorization mechanisms to validate who is allowed to perform what action on the account, by implementing standard interfaces.
Execution modules
- These modules define custom execution functions to facilitate the actions allowed by the account.
Standardizing Modularity for Smart Accounts
ERC 6900
is the first proposal that aims to standardize modularity for Smart Accounts, introduced by Alchemy in April 2023. It provides standards for how plugins (modules) should be written as well as how compliant accounts should add, update, remove, and inspect plugins.
Similarly,
ERC 7579
enables developers to standardize these modules with minimal impact on the implementation logic of the account. It was developed by Rhinestone, Biconomy, ZeroDev, and OKX and presented in December 2023. This proposal outlines the minimally required interfaces and behavior for smart accounts and modules to ensure interoperability across implementations.
ERC 7579 is less opinionated and allows developers to experiment and innovate, making their own trade-offs around complexity and security. In contrast, ERC 6900 is more prescriptive due to an extensive description of all the aspects of compliant account behavior.
How to enable modules
​
The Modular smart account is designed to be adaptable and flexible. Instead of storing ownership data internally or relying on a fixed signature verification method, it empowers users to choose their primary validation module. This flexibility, as part of Biconomy's
SmartAccountFactory
, ensures each account can validate userOps effectively and support diverse user requirements.
Modules can be enabled using the following methods:
During MSA deployment, a default validation module is enabled. Internally, it calls the
deployCounterFactualAccount
method on the smart account factory. The module selected to deploy the MSA determines its final address, due to its counterfactual nature.
A new module can be enabled via a userOp transaction on a smart account by specifying the module address and moduleSetupData. Internally, it calls
setupAndEnableModule
method on Module Manager. It can be set as an active validation module to be used for the next transactions.
const
isEnabled
=
await
smartAccount
.
isModuleEnabled
(
module_address
)
if
(
!
isEnabled
)
{
const
enableModuleTrx
=
await
smartAccount
.
getEnableModuleData
(
module_address
)
;
transactionArray
.
push
(
enableModuleTrx
)
;
}
smartAccount
=
smartAccount
.
setActiveValidationModule
(
module
)
As per the code, the initial step is to verify whether the module is already enabled. If the module is not enabled, a transaction can be performed to enable it.
note
The module passed during the deployment acts as the default validation module. This module gets used as an active validation module if no other module is enabled.
Validation Modules
​
The validation Module is a module that extends the abstract contract
BaseAuthorizationModule
** - which implements the
IBaseAuthorizationModule
interface. This interface requires the implementation of the following methods:
validateUserOp
: this method validates userOperation. It expects userOp callData to execute method calls of the Smart account and userOp signature being the ABI-encoded signature and module address.
isValidSignature
: this method validates an EIP-1271 signature.
isValidSignatureUnsafe
: this method validates an EIP-1271 signature but expects the data Hash to already include smart account address information.
Validation modules are invoked with a “call”. It has its own storage and doesn’t share storage with Biconomy Smart Account. Since validation module storage is accessed during the validation phase, ERC-4337
storage rules
apply to this.
info
Validation Modules in MSA play a crucial role in determining who can perform actions, ensuring security and proper authorization.
Following is the list of Validation Modules:
ECDSA Ownership Module
: This module is widely adopted as a validation module for Biconomy smart accounts. It can seamlessly integrate with MPC providers such as Web3Auth, abstracting EOA Private Key storage and enabling a web2-like experience such as email login.
Multichain ECDSA Validator Module
: This module significantly improves UX for deploying and setting up Smart Accounts on several chains. It is an extension of the ECDSA Module enabling to dispatch multiple userOps on different chains using a single signature.
Session key Manager Validation Module
: This module enables the use of sessions to execute transactions. It verifies whether a given user operation adheres to the permissions defined within the session key and confirms that the operation has been signed by that session key. This can only be used as an active validation module.
MultiOwnedECDSAModule
: This is an alteration of the ECDSA Module which allows multiple signers to be set up, and any one of the enabled owners can authorize a transaction using the ECDSA signature.
How to create a custom Validation Module
​
Developers have the flexibility to create a custom validation module according to their specific requirements. This validation module must extend the BaseAuthorizationModule, which further implements the IAuthorizationModule and ISignatureValidator interfaces.
Key Imports and Their Roles
BaseAuthorizationModule
Core Structure
: Forms the foundation of your custom module.
Link to Interfaces
: Connects to IAuthorizationModule and ISignatureValidator
IAuthorizationModule
Operation Validation
: Manages validation of user operations (userOp)
Method Implementation
: Defines methods for operation validation your module must implement.
ISignatureValidator
Signature Security & Standardization
: Focuses on signature validation and adheres to the ERC-1271 standard for smart contract-based signature
isValidSignature Method
: Essential for verifying signatures and ensuring security.
note
Adhering closely to the functionalities and specifications of these interfaces and standards is fundamental. It ensures your custom validation module operates securely and efficiently.
After thorough testing and auditing, a pull request (PR) can be submitted to integrate the module with the SDK. A detailed walkthrough of the same is linked
here
.
Execution Modules
​
Execution functions
execute any custom logic allowed by the account.
There are two default execution functions - called execute and executeBatch which allow for open-ended execution that is required for AA-flow. The custom execution module needs to call back into Smart Account to initialize a function call from within the context of the account.
The diagram below illustrates the execution flow for Modular Smart Accounts.
caution
Execution modules should be carefully developed and integrated, as they directly control the actions an account can perform.
Previous
Methods
Next
ECDSA Ownership
How to enable modules
Validation Modules
How to create a custom Validation Module
Execution Modules
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Gas Estimations SDK | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Integration
Methods
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Gas Estimations SDK
Version: SDK V4 (latest)
Gas Estimations SDK
The Gas estimation SDK enables you to estimate gas limits accurately. This functionality is packaged within an npm package, enabling other infrastructure providers to reuse the same logic.
While sending a userOp, It is essential to accurately estimate callGasLimit, verificationGasLimit and preVerficationGas. This ensures the userOp is included on the chain.
The exact definition of these values is mentioned in the ERC 4337 spec
here
.
Accurately estimating gas limits is crucial, as failure to do so may result in the following scenarios:
If preVerfiicationGas is not enough the userOp can be rejected by bundlers
If callGasLimit is not enough the transaction will be included on-chain but the call data execution will not be completed and the paymaster or account will still pay for the userOp
If verificationGasLimit is low the userOp will revert to the simulation step
All the above problems result in bad UX, failed and reverted transactions which are also hard to debug.
📄️
Integration
This guide focuses on the code to integrate the entry point gas estimations package.
📄️
Methods
estimateUserOperationGas
Previous
API Explorer
Next
Integration
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Bundler | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Integration
Methods
APIs
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Bundler
Version: SDK V4 (latest)
Bundler
The Bundler is a service that tracks userOps that exist in an alternative mem pool and as the name suggests, bundles them together to send to an Entry Point Contract for eventual execution on-chain.
This is the final piece of the flow where after constructing your
userOp
and then potentially signing it with data from a paymaster, you send the
userOp
on-chain to be handled and executed as a transaction on the EVM.
You can start using our Bundlers right now in your dApps; each of our
tutorials
will walk you through how to use them in different scenarios.
you can get the bundler url from
here
. In short, the Bundler is responsible for the following:
Aggregating userOps in an alternative
mempool
to normal Ethereum Transactions
Submitting to the Network: Bundlers EOA will send the
userOp
to the Entry Point Contract as a transaction
In the context of the Biconomy solution, you can access our Bundler infrastructure either through the packages of our SDK or via API requests. This section will cover both approaches in detail.
📄️
Integration
This guide focuses on the code to integrate the Bundler. To see how this interacts with other packages in the sdk you can view the Smart Accounts Integration page.
📄️
Methods
estimateUserOpGas
🗃️
APIs
9 items
Previous
Explorer
Next
Integration
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Paymaster | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Integration
Methods
APIs
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Paymaster
Version: SDK V4 (latest)
On this page
Paymaster
Paymasters are smart contracts that help facilitate transaction sponsorship, allowing third-party-designed mechanisms to pay for transactions.
With Biconomy's Paymaster service, you can manage gas fees for your users effortlessly.
Revenue sharing
: on a case-by-case basis depending on volumes, we do offer a split of the Paymaster fee revenue with selected Apps.
Get in touch
to learn more.
In order to use the it, you must
setup the paymaster
on the dashboard and obtain the paymasterURL. Biconomy paymaster supports two modes:
Sponsorship Paymaster
​
Sponsorship
mode allows you to pay gas on behalf of the users, by eliminating the need of native tokens to be paid by the users.
Token Paymaster
​
ERC20
mode allows you to pay for the gas fees of your users in exchange for ERC-20 tokens. Check out the latest
supported ERC-20 tokens
.
Learn how to utilize either of these Paymasters by checking out our How To Guide on
Executing transactions
In the following sections, we will more systematically introduce the following concepts:
📄️
Integration
To see how this interacts with other packages in the sdk you can view the Smart Accounts Integration page.
📄️
Methods
Imports needed for these methods:
🗃️
APIs
4 items
Previous
Smart Accounts : V1 to V2 Upgrade
Next
Integration
Sponsorship Paymaster
Token Paymaster
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Smart Accounts | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Integration
Methods
Signers
Enable Fiat On Ramp
Legacy Smart Account V1
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Smart Accounts
Version: SDK V4 (latest)
On this page
Smart Accounts
In the context ERC 4337, a smart account is a smart contract account used to manage assets and create
userOperations
or
userOps
.
These are pseudo-transaction objects that eventually execute as a transaction on the EVM.
They replace traditional Externally Owned Accounts (Wallets).
The Biconomy Smart Account
​
Biconomy Smart Accounts are an ERC 4337-compliant solution that works with any Paymaster and Bundler service.
These Smart Accounts are signer agnostic, which allows you to use any authorization package of your choice as long as you can pass a signer to our SDK upon the creation of a Smart Account.
Check out the different ways you can create a Biconomy Smart Account
here
.
Smart Accounts are further enhanced by validation modules that allow you to execute arbitrary logic before validating a
userOp
.
This allows you, as a developer, to build modules that allow for session keys, multi-chain validation modules, pass keys, and more. Learn more about Modules
here
.
In the following sections, we provide a detailed overview of key concepts including
📄️
Integration
Smart Accounts are created deterministically using the CREATE2 opcode, meaning the smart account address can be identified even before it is deployed. It will also maintain the same address across different chains.
📄️
Methods
The SDK provides the following API methods for a smart account.
🗃️
Signers
11 items
📄️
Enable Fiat On Ramp
BiconomySDK's Transak library is made for developers who just want on-ramp solutions and don't want to go through with all the steps to integrate the SDK.
🗃️
Legacy Smart Account V1
3 items
Previous
Transfer Ownership
Next
Integration
The Biconomy Smart Account
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Tutorials | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Send a simple transaction
Send a batch of transactions
Send a gasless transaction
Pay gas in ERC20 tokens
Send parallel user ops
Sessions
Custom Validation Module
Migrating to V4
API integration
Utilities
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Tutorials
Version: SDK V4 (latest)
Tutorials
📄️
Send a simple transaction
Overview
📄️
Send a batch of transactions
Overview
📄️
Send a gasless transaction
Overview
📄️
Pay gas in ERC20 tokens
Overview
📄️
Send parallel user ops
Overview
🗃️
Sessions
5 items
📄️
Custom Validation Module
This section of the tutorial requires Solidity knowledge and smart contract development
📄️
Migrating to V4
This guide provides instructions for migrating from v3 to v4. It outlines the changes introduced in the new version and offers guidance on updating your codebase to ensure compatibility.
🗃️
API integration
4 items
🗃️
Utilities
2 items
Previous
Quickstart
Next
Send a simple transaction
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Quickstart ⚡️ | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Quickstart
Version: SDK V4 (latest)
On this page
Quickstart ⚡️
In this guide, we will create a smart account and mint an NFT with
Biconomy's SDK
and Node.js.
info
For a detailed exploration of the SDK's inner workings, delve into our more granular
API documentation
.
1. Setup 🛠️
​
Let's create a
Typescript
project using npm to get started. Let's start by adding some tooling:
mkdir biconomy-sa && cd biconomy-sa && npm init -y && npm i --save-dev @types/node tslib
🎉 Then add biconomy's account package (with viem): 🎉
npm i @biconomy/account viem
Create the following tsconfig.json (TypeScript config):
{
"compilerOptions": {
"target": "es2020",
"module": "commonjs",
"declaration": true,
"outDir": "./lib",
"strict": true,
"esModuleInterop": true,
"skipLibCheck": true
},
"include": ["./**/*.ts"]
}
The
Account package
will help you with creating
Smart Account
and an interface with them to send transactions.
The same package can be used to also import the paymaster and bundler.
2. Create a Smart Account 🌟
​
The
Externally Owned Account (EOA)
corresponding to the private key will serve as the owner of the Smart Account we create. You can get the private key from wallets like MetaMask, TrustWallet, Coinbase Wallet, etc. 🔑
Create an index.ts file, copy the following code in it and replace the
PRIVATE_KEY
.
Be sure to never publicly expose your private key.
import
{
Hex
,
createWalletClient
,
encodeFunctionData
,
http
,
parseAbi
,
zeroAddress
,
}
from
"viem"
;
import
{
privateKeyToAccount
}
from
"viem/accounts"
;
import
{
polygonAmoy
}
from
"viem/chains"
;
import
{
createSmartAccountClient
}
from
"@biconomy/account"
;
const
bundlerUrl
=
"https://bundler.biconomy.io/api/v2/80002/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44"
;
// Found at https://dashboard.biconomy.io
export
const
createAccountAndMintNft
=
async
(
)
=>
{
// ----- 1. Generate EOA from private key
const
account
=
privateKeyToAccount
(
"0x"
+
"PRIVATE_KEY"
)
;
const
client
=
createWalletClient
(
{
account
,
chain
:
polygonAmoy
,
transport
:
http
(
)
,
}
)
;
const
eoa
=
client
.
account
.
address
;
console
.
log
(
`
EOA address:
${
eoa
}
`
)
;
// ------ 2. Create biconomy smart account instance
const
smartAccount
=
await
createSmartAccountClient
(
{
signer
:
client
,
bundlerUrl
,
}
)
;
const
saAddress
=
await
smartAccount
.
getAccountAddress
(
)
;
console
.
log
(
"SA Address"
,
saAddress
)
;
}
;
createAccountAndMintNft
(
)
;
Next, run the following command:
npx ts-node index.ts
You should see EOA and the smart account address in the console.
EOA address: 0x7d4EcAc73A5574447E0F38b8451DC9B29D8Fd083
SA Address 0x4dF23B78543F5c2F9CBCDF09956288B3e97bb9a4
Smart accounts are designed with a pre-determined address known prior to deployment. Users transfer funds to this address and then the actual deployment transaction is internally batched with the first transaction that is done by that smart Account. Alternatively the paymaster could be used to sponsor this transaction.
caution
Before continuing, now that we have our Smart Account address, we need to fund it with some test network tokens! Since we are using the Polygon Amoy network, head over to the
Polygon Faucet
, paste in your smart account address, and get some test tokens! If you skip this step, you might run into the
AA21 didn't pay prefund error
! 💸
Once you have tokens available, follow the next steps.
3. Execute your first transaction 🚀
​
Let's create your first transaction
to
: Smart Contract your Smart Account will interact with.
data
: For the mint function we will pass the
nftData
created using
encodeFunctionData
.
value
: For the mint function this won't be needed. Depending on the transaction, you can pass the value.
Add the following code in the script above at the bottom of the
createAccountAndMintNft
function.
try
{
const
nftAddress
=
"0x1758f42Af7026fBbB559Dc60EcE0De3ef81f665e"
;
const
parsedAbi
=
parseAbi
(
[
"function safeMint(address _to)"
]
)
;
const
nftData
=
encodeFunctionData
(
{
abi
:
parsedAbi
,
functionName
:
"safeMint"
,
args
:
[
saAddress
as
Hex
]
,
}
)
;
// ------ 4. Send transaction
const
userOpResponse
=
await
smartAccount
.
sendTransaction
(
{
to
:
nftAddress
,
data
:
nftData
,
}
)
;
const
{
transactionHash
}
=
await
userOpResponse
.
waitForTxHash
(
)
;
console
.
log
(
"transactionHash"
,
transactionHash
)
;
const
userOpReceipt
=
await
userOpResponse
.
wait
(
)
;
if
(
userOpReceipt
.
success
==
"true"
)
{
console
.
log
(
"UserOp receipt"
,
userOpReceipt
)
;
console
.
log
(
"Transaction receipt"
,
userOpReceipt
.
receipt
)
;
}
}
catch
(
error
:
unknown
)
{
if
(
error
instanceof
Error
)
{
console
.
error
(
"Transaction Error:"
,
error
.
message
)
;
}
}
We create a transaction object.
We send the
transaction
to our bundler.
We store the response in a variable called
transactionResponse
.
We retrieve the transaction detail by calling
userOpResponse.waitForTxHash()
.
To wait for a specific number of network confirmations before getting the value, use
wait()
with a number argument.
For instance,
transactionResponse.wait(5)
waits for 5 confirmations before returning the value.
Check out the long transaction details available now in your console! You just created and executed your first userOps using the Biconomy SDK. The entire Biconomy crew is sending you a big round of applause! 👏👏🏻👏🏼👏🏽👏🏾👏🏿
You can also view the latest transaction events on the
Polygon Amoy Testnet Explorer
.
View Complete Code
import
{
Hex
,
createWalletClient
,
encodeFunctionData
,
http
,
parseAbi
,
zeroAddress
,
}
from
"viem"
;
import
{
privateKeyToAccount
}
from
"viem/accounts"
;
import
{
polygonAmoy
}
from
"viem/chains"
;
import
{
createSmartAccountClient
}
from
"@biconomy/account"
;
export
const
createAccountAndMintNft
=
async
(
)
=>
{
// ----- 1. Generate EOA from private key
const
account
=
privateKeyToAccount
(
"0x"
+
"PRIVATE_KEY"
)
;
const
client
=
createWalletClient
(
{
account
,
chain
:
polygonAmoy
,
transport
:
http
(
)
,
}
)
;
const
eoa
=
client
.
account
.
address
;
console
.
log
(
`
EOA address:
${
eoa
}
`
)
;
// ------ 2. Create biconomy smart account instance
const
smartAccount
=
await
createSmartAccountClient
(
{
signer
:
client
,
bundlerUrl
:
"https://bundler.biconomy.io/api/v2/80002/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44"
,
}
)
;
const
saAddress
=
await
smartAccount
.
getAccountAddress
(
)
;
console
.
log
(
"SA Address"
,
saAddress
)
;
// ------ 3. Generate transaction data
const
nftAddress
=
"0x1758f42Af7026fBbB559Dc60EcE0De3ef81f665e"
;
const
parsedAbi
=
parseAbi
(
[
"function safeMint(address _to)"
]
)
;
const
nftData
=
encodeFunctionData
(
{
abi
:
parsedAbi
,
functionName
:
"safeMint"
,
args
:
[
saAddress
as
Hex
]
,
}
)
;
// ------ 4. Send transaction
const
userOpResponse
=
await
smartAccount
.
sendTransaction
(
{
to
:
nftAddress
,
data
:
nftData
,
}
)
;
const
{
transactionHash
}
=
await
userOpResponse
.
waitForTxHash
(
)
;
console
.
log
(
"transactionHash"
,
transactionHash
)
;
const
userOpReceipt
=
await
userOpResponse
.
wait
(
)
;
if
(
userOpReceipt
.
success
==
"true"
)
{
console
.
log
(
"UserOp receipt"
,
userOpReceipt
)
;
console
.
log
(
"Transaction receipt"
,
userOpReceipt
.
receipt
)
;
}
}
;
createAccountAndMintNft
(
)
;
If you run into any errors, check out
troubleshooting
for common errors.
🎉
Congratulations on completing the quickstart!
Check out Tutorials
​
Explore the tutorials for various use cases.
Send a batch of transactions
​
In this you will do batching of transactions which is sending more than one transaction in an array and execute them with a single signature.
Send a gasless transaction
​
In this you will do a gasless transaction for which you will not have to pay any gas fees and with empty funds in your smart account you can execute transactions.
Pay gas in ERC20
​
In this you will execute a transaction by paying gas fees in ERC20 tokens, for this your smart account should have the specific ERC20 token for paying gas fees.
To dive deeper, check out more
use cases
.
Previous
Overview
Next
Tutorials
1. Setup 🛠️
2. Create a Smart Account 🌟
3. Execute your first transaction 🚀
Check out Tutorials
Send a batch of transactions
Send a gasless transaction
Pay gas in ERC20
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Supported Networks | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Supported Networks & Tokens
Version: SDK V4 (latest)
On this page
Supported Networks
This is the list of networks supported by our Bundlers & Paymaster.
Network
Testnet
Mainnet
Ethereum
✅
✅
Polygon
✅
✅
BSC
✅
✅
Polygon zkEVM
✅
✅
Arbitrum One
✅
✅
Arbitrum Nova
✅
✅
Optimism
✅ (Sepolia)
✅
Avalanche
✅
✅
Base
✅
✅
Linea
✅
✅
Chiliz
✅
✅
Astar
✅
✅
opBNB
✅
✅
Manta
✅
✅
Core
✅
✅
Combo
✅
✅
Mantle
✅ (Sepolia)
✅
Blast
✅
✅
Zeroone
✅
✅
Scroll
✅
✅
Bera
✅
Zetachain
✅
✅
Gold (L3 on Base)
✅
Degenchain
✅
Olive
✅
Polygon zkEVM Cardona
✅
Gnosis
✅
✅
X Layer
✅
✅
Supported Tokens
​
Our Paymaster not only allows you to sponsor transactions for your users but also allows users to pay for transactions using ERC20 tokens. Below are the supported tokens list grouped by chain.
Please note that we will be reviewing DEX activity on each network to determine additional ERC20 token support on an ongoing basis.
Loading...
Previous
FAQ
Supported Tokens
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

FAQ | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
FAQ
Version: SDK V4 (latest)
On this page
FAQ
Smart accounts and SDK
​
Will I get the same smart account address on all chains?
Yes, you will get the same address on all chains as long as the owner's address is the same.
How can I create another smart account using the same EOA on the same chain?
you can pass the
index
in the config while creating the account as mentioned in the createSmartAccountClient
method
. First smart account gets created with index 0 by default.
Where can I find more examples of SDK integrations?
https://github.com/bcnmy/sdk-examples
How can I increase the timeout in the waitForTransactionHash function?
Initialize the bundler with updated configuration, to increase the timeout (milliseconds).
import
{
createSmartAccountClient
,
createBundler
}
from
"@biconomy/account"
;
const
biconomySmartAccount
=
await
createSmartAccountClient
(
{
signer
,
bundler
:
await
createBundler
(
{
bundlerUrl
:
"bundler url"
,
userOpReceiptMaxDurationIntervals
:
{
80002
:
60000
}
,
}
)
,
}
)
;
Which social login methods are supported?
Explore services such as Web3Auth, Particle Network, Magic.link, or Lit Protocol to link a user's social identity with a cryptographic key. This key can then serve as the owner of the Smart Account. Be sure to check out various
signers
integrations for this purpose.
How do I enable session keys for users?
Utilize the session key validation
module
.
How to enable debug mode in SDK to log more?
Set following env flag to true before running the app.
export BICONOMY_SDK_DEBUG=true
What are 2D Nonces?
In account abstraction, user operations use two-dimensional (2D) nonces. This is different from EOAs (Externally Owned Accounts), which currently use one-dimensional nonces. For EOAs, every transaction increases the nonce by 1, following a sequential order.
A User Operation is similar in that it can generate sequential nonces (when nonceKey is 0), but it also has the ability to use 2D nonces (when nonceKey > 0), allowing for parallel user operations.
Here's what happens under the hood of the getNonce() method:
return
nonceSequenceNumber
[
sender
]
[
key
]
|
(
uint256
(
key
)
<<
64
)
The current key sequence is combined with a left-shifted value of the same key. The end result is a single number representing all possible 2D nonces.
What are Parallel User Ops?
Parallel user ops are user operations that are not dependent on each other and can be executed simultaneously, without waiting for any previous user operation to be executed on-chain.
Let's take an example of a user executing some actions on a Dapp. The Dapp wants to batch transactions together to provide a better user experience (UX).
Bob
swaps
1
ETH
for
4000
USDC
Bob
swaps
4000
USDC
for
7000
BICO
Bob
buys
1
NFT
for
100
USDC
Transactions 1 and 2 will be batched into one user operation and will be executed in order, while transaction 3 will be added in another user operation.
The second user operation can be sent after the first one is done, using a sequential nonce, this means it will wait for the first user operation to be settled on-chain. However, we can do better. By using 2D nonces, we can send both user ops at the same time. While Bob is swapping ETH for USDC and USDC for BICO, he can also buy that cool NFT simultaneously.
Here is a tutorial on how to send parallel user ops with the Biconomy SDK:
https://docs.biconomy.io/tutorials/parallelUserOps
Bundler & Paymaster
​
Is the bundler URL the same for all chains?
Yes, for testnets same
bundler URL
can be used, just change the chainId. For mainnet you can reach out to
us
.
How can I sign the userOp manually?
To sign the userOp manually, first calculate the userOpHash and then sign it using the same signer, the account is created with. you can find more details
here
.
Can I just use Biconomy’s bundler with another smart account implementation?
Yes, Biconomy's bundler seamlessly integrates with other smart account providers. As long as the user operation remains valid and complies with ERC 4337 specifications, the integration is possible.
Which ERC20 tokens are supported by the biconomy paymaster? How can I add support for a custom ERC20 token?
You can check out the list of supported networks
here
. You can reach out to us here for custom token requirements.
Can I use other paymaster with Biconomy SDK?
Yes, you can. It completely depends on how the
paymasterAndData
is parsed in the paymaster. The only restriction is that it should first encode the paymaster address after that encoding can be anything till the time decoding is consistent. Bundler does not care about the paymasterAndData.
Can I fund the gasTank programmatically?
You can programmatically deposit funds using the paymasterContract
depositFor
function by passing the
amount
and
paymasterId
which is the EOA address. For instance, you can invoke the following
function
on the Polygon chain. Check out
this
script for the same.
Are there APIs to create my own dashboard?
Yes, you can utilize the
dashboard APIs
to create a paymaster, change policies, and even get the transaction's data.
Previous
Audits
Next
Supported Networks & Tokens
Smart accounts and SDK
Bundler & Paymaster
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Audits | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Audits
Version: SDK V4 (latest)
On this page
Audits
Smart Accounts and Modules
​
Title
Auditor
Link
Biconomy Smart Account
Zellic
Link to report
Smart Account and Session Keys
Kawach
Link to report
PasskeyRegistry and SessionKey Manager
Zellic
Link to report
Account Recovery Module
Zellic
Link to report
Account Recovery Module
Kawach
Link to report
Batched Session Router module
Zellic
Link to report
Batched Session Router module
Kawach
Link to report
Multichain Validator
Zellic
Link to report
Multichain Validator
Kawach
Link to report
Biconomy Multi Owned ECDSA
Zellic
Link to report
Paymasters
​
Audit Title
Link
Zellic Paymaster
Link to report
Zellic Token Paymaster
Link to report
Previous
Contract Addresses
Next
FAQ
Smart Accounts and Modules
Paymasters
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Audits | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Audits
Version: SDK V4 (latest)
On this page
Audits
Smart Accounts and Modules
​
Title
Auditor
Link
Biconomy Smart Account
Zellic
Link to report
Smart Account and Session Keys
Kawach
Link to report
PasskeyRegistry and SessionKey Manager
Zellic
Link to report
Account Recovery Module
Zellic
Link to report
Account Recovery Module
Kawach
Link to report
Batched Session Router module
Zellic
Link to report
Batched Session Router module
Kawach
Link to report
Multichain Validator
Zellic
Link to report
Multichain Validator
Kawach
Link to report
Biconomy Multi Owned ECDSA
Zellic
Link to report
Paymasters
​
Audit Title
Link
Zellic Paymaster
Link to report
Zellic Token Paymaster
Link to report
Previous
Contract Addresses
Next
FAQ
Smart Accounts and Modules
Paymasters
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Contract Addresses | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Contract Addresses
Version: SDK V4 (latest)
On this page
Contract Addresses
info
These contracts are deployed across all supported chains.
Entry points
​
Contract Name
Address
Entry point (chiliz mainnet & testnet)
0x00000061FEfce24A79343c27127435286BB7A4E1
Entry point (all the other chains)
0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789
Smart Account
​
Contract Name
Address
Smart Account Implementation V2
0x0000002512019Dafb59528B82CB92D3c5D2423aC
Smart Account Factory V2
0x000000a56Aaca3e9a4C479ea6b6CD0DbcB6634F5
ECDSA Ownership Module
0x0000001c5b32F37F5beA87BDD5374eB2aC54eA8e
Multichain Validation Module
0x000000824dc138db84FD9109fc154bdad332Aa8E
Batched Session Router Module
0x000008dA71757C0E1D83CE56c823e25Aa49bC058
ABI Session Validation Module
0x000006bC2eCdAe38113929293d241Cf252D91861
Session Key Manager V1
0x000002FbFfedd9B33F4E7156F2DE8D48945E7489
Verifying Paymaster V1
0x000031DD6D9D3A133E663660b959162870D755D4
Verifying Paymaster V1.1.0
0x00000f79b7faf42eebadba19acc07cd08af44789
Token Paymaster
0x00000f7365cA6C59A2C93719ad53d567ed49c14C
Legacy: Smart Account V1
​
Contract Name
Address
Smart Account Implementation V1
0x00006B7e42e01957dA540Dc6a8F7C30c4D816af5
Smart Account Factory V1
0x000000F9eE1842Bb72F6BBDD75E6D3d4e3e9594C
Blast Gold Addresses
​
Contract Name
Address
Points Operator address
0x2cf491602ad22944D9047282aBC00D3e52F56B37
Deployed Smart Contract
0x7f4FB6A17A84aAc3e16BbC0C8d03Ca563aB0c483
info
It is recommended to use Verifying Paymaster V1.1.0 as this includes all features in previous version as well as features such as expirations for paymaster requests.
Previous
Polyfill Errors
Next
Audits
Entry points
Smart Account
Legacy: Smart Account V1
Blast Gold Addresses
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Troubleshooting | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Common Errors
Polyfill Errors
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Troubleshooting
Version: SDK V4 (latest)
Troubleshooting
Troubleshooting errors while working with the Biconomy SDK
📄️
Common Errors
We are sorry to cause any inconvenience while interacting with biconomy SDK. We are trying our best to send meaningful error messages that can help you do quick fixes without interacting with any support channel. Some of the error messages are not in our control as we are using some standard contract ( e.g EntryPoint ) to provider gasless experience. Following are some standard error messages that can help you apply quick fixes and sort the issues.
📄️
Polyfill Errors
With many web3 tools you may run into Polyfill issues with error messages like 'crypto' not found, or 'buffer' not found. These are caused by Node JS Polyfills that are no longer included with Webpack after version 5. You can read more about the full details of this here.
Previous
APIs
Next
Common Errors
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Dashboard | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Version: SDK V4 (latest)
On this page
Dashboard
The Biconomy dashboard is your gateway to accessing our services such as Paymaster, Bundlers, and allows you to retrieve your API keys for usage with our SDK and API. Additionally, this is where you can top up and configure your Paymasters for sponsoring transactions.
info
Please note that this documentation refers to our Account Abstraction SDK solution. If you need information about the EOA gasless dashboard please refer to these
docs
Login
​
The Biconomy Dashboard can be found at
dashboard.biconomy.io/
. Several sign in options are available including Email, Github, and Gitlab.
Paymaster Keys
​
Paymaster keys can be found on the Overview page of the paymasters. You can copy your Paymaster API Key as well as your Paymaster URL as shown below
Bundler URL
​
Our Bundler as a service is coming soon but for now you can use the following URL for your bundler package:
https://bundler.biconomy.io/api/v2/{chain-id-here}/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44
For a Bundler URL on mainnet, please contact
us
.
In the following sections, we will more systematically introduce the following concepts:
📄️
Create a Paymaster
Add Paymaster
📄️
Paymaster Rules
For a paymaster, you can restrict the sponsorship to only specified contracts and methods if needed. If no contract is whitelisted, then paymaster will facilitate all the contract interactions.
📄️
Spending Limits
This feature allows you to set limits to the gas usage. You can define global limits or per-user quotas, specifying either transaction count or total gas consumption.
📄️
Organizations
The organization feature is designed to enhance collaboration and streamline team management within your workspace.
📄️
APIs
Using these APIs allow you to perform various actions without the need to access the dashboard UI manually.
Previous
ABI Session Validation Module
Next
Create a Paymaster
Login
Paymaster Keys
Bundler URL
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Modules | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
Version: SDK V4 (latest)
On this page
Modules
Modular smart accounts (MSA) offer more flexibility than 'static' accounts. Static accounts often need a developer for changes and involve complex proxy upgrades. In contrast, with MSA the functionalities are moved to external contracts called
modules
to increase the speed of feature development. MSA lets users install or uninstall these modules, avoiding the need for entire account redeployment.
Biconomy MSA (Modular Smart Account) has two types of modules:
Validation modules
- These modules define different signature schemes or authorization mechanisms to validate who is allowed to perform what action on the account, by implementing standard interfaces.
Execution modules
- These modules define custom execution functions to facilitate the actions allowed by the account.
Standardizing Modularity for Smart Accounts
ERC 6900
is the first proposal that aims to standardize modularity for Smart Accounts, introduced by Alchemy in April 2023. It provides standards for how plugins (modules) should be written as well as how compliant accounts should add, update, remove, and inspect plugins.
Similarly,
ERC 7579
enables developers to standardize these modules with minimal impact on the implementation logic of the account. It was developed by Rhinestone, Biconomy, ZeroDev, and OKX and presented in December 2023. This proposal outlines the minimally required interfaces and behavior for smart accounts and modules to ensure interoperability across implementations.
ERC 7579 is less opinionated and allows developers to experiment and innovate, making their own trade-offs around complexity and security. In contrast, ERC 6900 is more prescriptive due to an extensive description of all the aspects of compliant account behavior.
How to enable modules
​
The Modular smart account is designed to be adaptable and flexible. Instead of storing ownership data internally or relying on a fixed signature verification method, it empowers users to choose their primary validation module. This flexibility, as part of Biconomy's
SmartAccountFactory
, ensures each account can validate userOps effectively and support diverse user requirements.
Modules can be enabled using the following methods:
During MSA deployment, a default validation module is enabled. Internally, it calls the
deployCounterFactualAccount
method on the smart account factory. The module selected to deploy the MSA determines its final address, due to its counterfactual nature.
A new module can be enabled via a userOp transaction on a smart account by specifying the module address and moduleSetupData. Internally, it calls
setupAndEnableModule
method on Module Manager. It can be set as an active validation module to be used for the next transactions.
const
isEnabled
=
await
smartAccount
.
isModuleEnabled
(
module_address
)
if
(
!
isEnabled
)
{
const
enableModuleTrx
=
await
smartAccount
.
getEnableModuleData
(
module_address
)
;
transactionArray
.
push
(
enableModuleTrx
)
;
}
smartAccount
=
smartAccount
.
setActiveValidationModule
(
module
)
As per the code, the initial step is to verify whether the module is already enabled. If the module is not enabled, a transaction can be performed to enable it.
note
The module passed during the deployment acts as the default validation module. This module gets used as an active validation module if no other module is enabled.
Validation Modules
​
The validation Module is a module that extends the abstract contract
BaseAuthorizationModule
** - which implements the
IBaseAuthorizationModule
interface. This interface requires the implementation of the following methods:
validateUserOp
: this method validates userOperation. It expects userOp callData to execute method calls of the Smart account and userOp signature being the ABI-encoded signature and module address.
isValidSignature
: this method validates an EIP-1271 signature.
isValidSignatureUnsafe
: this method validates an EIP-1271 signature but expects the data Hash to already include smart account address information.
Validation modules are invoked with a “call”. It has its own storage and doesn’t share storage with Biconomy Smart Account. Since validation module storage is accessed during the validation phase, ERC-4337
storage rules
apply to this.
info
Validation Modules in MSA play a crucial role in determining who can perform actions, ensuring security and proper authorization.
Following is the list of Validation Modules:
ECDSA Ownership Module
: This module is widely adopted as a validation module for Biconomy smart accounts. It can seamlessly integrate with MPC providers such as Web3Auth, abstracting EOA Private Key storage and enabling a web2-like experience such as email login.
Multichain ECDSA Validator Module
: This module significantly improves UX for deploying and setting up Smart Accounts on several chains. It is an extension of the ECDSA Module enabling to dispatch multiple userOps on different chains using a single signature.
Session key Manager Validation Module
: This module enables the use of sessions to execute transactions. It verifies whether a given user operation adheres to the permissions defined within the session key and confirms that the operation has been signed by that session key. This can only be used as an active validation module.
MultiOwnedECDSAModule
: This is an alteration of the ECDSA Module which allows multiple signers to be set up, and any one of the enabled owners can authorize a transaction using the ECDSA signature.
How to create a custom Validation Module
​
Developers have the flexibility to create a custom validation module according to their specific requirements. This validation module must extend the BaseAuthorizationModule, which further implements the IAuthorizationModule and ISignatureValidator interfaces.
Key Imports and Their Roles
BaseAuthorizationModule
Core Structure
: Forms the foundation of your custom module.
Link to Interfaces
: Connects to IAuthorizationModule and ISignatureValidator
IAuthorizationModule
Operation Validation
: Manages validation of user operations (userOp)
Method Implementation
: Defines methods for operation validation your module must implement.
ISignatureValidator
Signature Security & Standardization
: Focuses on signature validation and adheres to the ERC-1271 standard for smart contract-based signature
isValidSignature Method
: Essential for verifying signatures and ensuring security.
note
Adhering closely to the functionalities and specifications of these interfaces and standards is fundamental. It ensures your custom validation module operates securely and efficiently.
After thorough testing and auditing, a pull request (PR) can be submitted to integrate the module with the SDK. A detailed walkthrough of the same is linked
here
.
Execution Modules
​
Execution functions
execute any custom logic allowed by the account.
There are two default execution functions - called execute and executeBatch which allow for open-ended execution that is required for AA-flow. The custom execution module needs to call back into Smart Account to initialize a function call from within the context of the account.
The diagram below illustrates the execution flow for Modular Smart Accounts.
caution
Execution modules should be carefully developed and integrated, as they directly control the actions an account can perform.
Previous
Methods
Next
ECDSA Ownership
How to enable modules
Validation Modules
How to create a custom Validation Module
Execution Modules
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Gas Estimations SDK | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Integration
Methods
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Gas Estimations SDK
Version: SDK V4 (latest)
Gas Estimations SDK
The Gas estimation SDK enables you to estimate gas limits accurately. This functionality is packaged within an npm package, enabling other infrastructure providers to reuse the same logic.
While sending a userOp, It is essential to accurately estimate callGasLimit, verificationGasLimit and preVerficationGas. This ensures the userOp is included on the chain.
The exact definition of these values is mentioned in the ERC 4337 spec
here
.
Accurately estimating gas limits is crucial, as failure to do so may result in the following scenarios:
If preVerfiicationGas is not enough the userOp can be rejected by bundlers
If callGasLimit is not enough the transaction will be included on-chain but the call data execution will not be completed and the paymaster or account will still pay for the userOp
If verificationGasLimit is low the userOp will revert to the simulation step
All the above problems result in bad UX, failed and reverted transactions which are also hard to debug.
📄️
Integration
This guide focuses on the code to integrate the entry point gas estimations package.
📄️
Methods
estimateUserOperationGas
Previous
API Explorer
Next
Integration
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Bundler | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Integration
Methods
APIs
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Bundler
Version: SDK V4 (latest)
Bundler
The Bundler is a service that tracks userOps that exist in an alternative mem pool and as the name suggests, bundles them together to send to an Entry Point Contract for eventual execution on-chain.
This is the final piece of the flow where after constructing your
userOp
and then potentially signing it with data from a paymaster, you send the
userOp
on-chain to be handled and executed as a transaction on the EVM.
You can start using our Bundlers right now in your dApps; each of our
tutorials
will walk you through how to use them in different scenarios.
you can get the bundler url from
here
. In short, the Bundler is responsible for the following:
Aggregating userOps in an alternative
mempool
to normal Ethereum Transactions
Submitting to the Network: Bundlers EOA will send the
userOp
to the Entry Point Contract as a transaction
In the context of the Biconomy solution, you can access our Bundler infrastructure either through the packages of our SDK or via API requests. This section will cover both approaches in detail.
📄️
Integration
This guide focuses on the code to integrate the Bundler. To see how this interacts with other packages in the sdk you can view the Smart Accounts Integration page.
📄️
Methods
estimateUserOpGas
🗃️
APIs
9 items
Previous
Explorer
Next
Integration
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Paymaster | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Integration
Methods
APIs
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Paymaster
Version: SDK V4 (latest)
On this page
Paymaster
Paymasters are smart contracts that help facilitate transaction sponsorship, allowing third-party-designed mechanisms to pay for transactions.
With Biconomy's Paymaster service, you can manage gas fees for your users effortlessly.
Revenue sharing
: on a case-by-case basis depending on volumes, we do offer a split of the Paymaster fee revenue with selected Apps.
Get in touch
to learn more.
In order to use the it, you must
setup the paymaster
on the dashboard and obtain the paymasterURL. Biconomy paymaster supports two modes:
Sponsorship Paymaster
​
Sponsorship
mode allows you to pay gas on behalf of the users, by eliminating the need of native tokens to be paid by the users.
Token Paymaster
​
ERC20
mode allows you to pay for the gas fees of your users in exchange for ERC-20 tokens. Check out the latest
supported ERC-20 tokens
.
Learn how to utilize either of these Paymasters by checking out our How To Guide on
Executing transactions
In the following sections, we will more systematically introduce the following concepts:
📄️
Integration
To see how this interacts with other packages in the sdk you can view the Smart Accounts Integration page.
📄️
Methods
Imports needed for these methods:
🗃️
APIs
4 items
Previous
Smart Accounts : V1 to V2 Upgrade
Next
Integration
Sponsorship Paymaster
Token Paymaster
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Smart Accounts | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Integration
Methods
Signers
Enable Fiat On Ramp
Legacy Smart Account V1
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Smart Accounts
Version: SDK V4 (latest)
On this page
Smart Accounts
In the context ERC 4337, a smart account is a smart contract account used to manage assets and create
userOperations
or
userOps
.
These are pseudo-transaction objects that eventually execute as a transaction on the EVM.
They replace traditional Externally Owned Accounts (Wallets).
The Biconomy Smart Account
​
Biconomy Smart Accounts are an ERC 4337-compliant solution that works with any Paymaster and Bundler service.
These Smart Accounts are signer agnostic, which allows you to use any authorization package of your choice as long as you can pass a signer to our SDK upon the creation of a Smart Account.
Check out the different ways you can create a Biconomy Smart Account
here
.
Smart Accounts are further enhanced by validation modules that allow you to execute arbitrary logic before validating a
userOp
.
This allows you, as a developer, to build modules that allow for session keys, multi-chain validation modules, pass keys, and more. Learn more about Modules
here
.
In the following sections, we provide a detailed overview of key concepts including
📄️
Integration
Smart Accounts are created deterministically using the CREATE2 opcode, meaning the smart account address can be identified even before it is deployed. It will also maintain the same address across different chains.
📄️
Methods
The SDK provides the following API methods for a smart account.
🗃️
Signers
11 items
📄️
Enable Fiat On Ramp
BiconomySDK's Transak library is made for developers who just want on-ramp solutions and don't want to go through with all the steps to integrate the SDK.
🗃️
Legacy Smart Account V1
3 items
Previous
Transfer Ownership
Next
Integration
The Biconomy Smart Account
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Tutorials | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Send a simple transaction
Send a batch of transactions
Send a gasless transaction
Pay gas in ERC20 tokens
Send parallel user ops
Sessions
Custom Validation Module
Migrating to V4
API integration
Utilities
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Tutorials
Version: SDK V4 (latest)
Tutorials
📄️
Send a simple transaction
Overview
📄️
Send a batch of transactions
Overview
📄️
Send a gasless transaction
Overview
📄️
Pay gas in ERC20 tokens
Overview
📄️
Send parallel user ops
Overview
🗃️
Sessions
5 items
📄️
Custom Validation Module
This section of the tutorial requires Solidity knowledge and smart contract development
📄️
Migrating to V4
This guide provides instructions for migrating from v3 to v4. It outlines the changes introduced in the new version and offers guidance on updating your codebase to ensure compatibility.
🗃️
API integration
4 items
🗃️
Utilities
2 items
Previous
Quickstart
Next
Send a simple transaction
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Quickstart ⚡️ | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Quickstart
Version: SDK V4 (latest)
On this page
Quickstart ⚡️
In this guide, we will create a smart account and mint an NFT with
Biconomy's SDK
and Node.js.
info
For a detailed exploration of the SDK's inner workings, delve into our more granular
API documentation
.
1. Setup 🛠️
​
Let's create a
Typescript
project using npm to get started. Let's start by adding some tooling:
mkdir biconomy-sa && cd biconomy-sa && npm init -y && npm i --save-dev @types/node tslib
🎉 Then add biconomy's account package (with viem): 🎉
npm i @biconomy/account viem
Create the following tsconfig.json (TypeScript config):
{
"compilerOptions": {
"target": "es2020",
"module": "commonjs",
"declaration": true,
"outDir": "./lib",
"strict": true,
"esModuleInterop": true,
"skipLibCheck": true
},
"include": ["./**/*.ts"]
}
The
Account package
will help you with creating
Smart Account
and an interface with them to send transactions.
The same package can be used to also import the paymaster and bundler.
2. Create a Smart Account 🌟
​
The
Externally Owned Account (EOA)
corresponding to the private key will serve as the owner of the Smart Account we create. You can get the private key from wallets like MetaMask, TrustWallet, Coinbase Wallet, etc. 🔑
Create an index.ts file, copy the following code in it and replace the
PRIVATE_KEY
.
Be sure to never publicly expose your private key.
import
{
Hex
,
createWalletClient
,
encodeFunctionData
,
http
,
parseAbi
,
zeroAddress
,
}
from
"viem"
;
import
{
privateKeyToAccount
}
from
"viem/accounts"
;
import
{
polygonAmoy
}
from
"viem/chains"
;
import
{
createSmartAccountClient
}
from
"@biconomy/account"
;
const
bundlerUrl
=
"https://bundler.biconomy.io/api/v2/80002/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44"
;
// Found at https://dashboard.biconomy.io
export
const
createAccountAndMintNft
=
async
(
)
=>
{
// ----- 1. Generate EOA from private key
const
account
=
privateKeyToAccount
(
"0x"
+
"PRIVATE_KEY"
)
;
const
client
=
createWalletClient
(
{
account
,
chain
:
polygonAmoy
,
transport
:
http
(
)
,
}
)
;
const
eoa
=
client
.
account
.
address
;
console
.
log
(
`
EOA address:
${
eoa
}
`
)
;
// ------ 2. Create biconomy smart account instance
const
smartAccount
=
await
createSmartAccountClient
(
{
signer
:
client
,
bundlerUrl
,
}
)
;
const
saAddress
=
await
smartAccount
.
getAccountAddress
(
)
;
console
.
log
(
"SA Address"
,
saAddress
)
;
}
;
createAccountAndMintNft
(
)
;
Next, run the following command:
npx ts-node index.ts
You should see EOA and the smart account address in the console.
EOA address: 0x7d4EcAc73A5574447E0F38b8451DC9B29D8Fd083
SA Address 0x4dF23B78543F5c2F9CBCDF09956288B3e97bb9a4
Smart accounts are designed with a pre-determined address known prior to deployment. Users transfer funds to this address and then the actual deployment transaction is internally batched with the first transaction that is done by that smart Account. Alternatively the paymaster could be used to sponsor this transaction.
caution
Before continuing, now that we have our Smart Account address, we need to fund it with some test network tokens! Since we are using the Polygon Amoy network, head over to the
Polygon Faucet
, paste in your smart account address, and get some test tokens! If you skip this step, you might run into the
AA21 didn't pay prefund error
! 💸
Once you have tokens available, follow the next steps.
3. Execute your first transaction 🚀
​
Let's create your first transaction
to
: Smart Contract your Smart Account will interact with.
data
: For the mint function we will pass the
nftData
created using
encodeFunctionData
.
value
: For the mint function this won't be needed. Depending on the transaction, you can pass the value.
Add the following code in the script above at the bottom of the
createAccountAndMintNft
function.
try
{
const
nftAddress
=
"0x1758f42Af7026fBbB559Dc60EcE0De3ef81f665e"
;
const
parsedAbi
=
parseAbi
(
[
"function safeMint(address _to)"
]
)
;
const
nftData
=
encodeFunctionData
(
{
abi
:
parsedAbi
,
functionName
:
"safeMint"
,
args
:
[
saAddress
as
Hex
]
,
}
)
;
// ------ 4. Send transaction
const
userOpResponse
=
await
smartAccount
.
sendTransaction
(
{
to
:
nftAddress
,
data
:
nftData
,
}
)
;
const
{
transactionHash
}
=
await
userOpResponse
.
waitForTxHash
(
)
;
console
.
log
(
"transactionHash"
,
transactionHash
)
;
const
userOpReceipt
=
await
userOpResponse
.
wait
(
)
;
if
(
userOpReceipt
.
success
==
"true"
)
{
console
.
log
(
"UserOp receipt"
,
userOpReceipt
)
;
console
.
log
(
"Transaction receipt"
,
userOpReceipt
.
receipt
)
;
}
}
catch
(
error
:
unknown
)
{
if
(
error
instanceof
Error
)
{
console
.
error
(
"Transaction Error:"
,
error
.
message
)
;
}
}
We create a transaction object.
We send the
transaction
to our bundler.
We store the response in a variable called
transactionResponse
.
We retrieve the transaction detail by calling
userOpResponse.waitForTxHash()
.
To wait for a specific number of network confirmations before getting the value, use
wait()
with a number argument.
For instance,
transactionResponse.wait(5)
waits for 5 confirmations before returning the value.
Check out the long transaction details available now in your console! You just created and executed your first userOps using the Biconomy SDK. The entire Biconomy crew is sending you a big round of applause! 👏👏🏻👏🏼👏🏽👏🏾👏🏿
You can also view the latest transaction events on the
Polygon Amoy Testnet Explorer
.
View Complete Code
import
{
Hex
,
createWalletClient
,
encodeFunctionData
,
http
,
parseAbi
,
zeroAddress
,
}
from
"viem"
;
import
{
privateKeyToAccount
}
from
"viem/accounts"
;
import
{
polygonAmoy
}
from
"viem/chains"
;
import
{
createSmartAccountClient
}
from
"@biconomy/account"
;
export
const
createAccountAndMintNft
=
async
(
)
=>
{
// ----- 1. Generate EOA from private key
const
account
=
privateKeyToAccount
(
"0x"
+
"PRIVATE_KEY"
)
;
const
client
=
createWalletClient
(
{
account
,
chain
:
polygonAmoy
,
transport
:
http
(
)
,
}
)
;
const
eoa
=
client
.
account
.
address
;
console
.
log
(
`
EOA address:
${
eoa
}
`
)
;
// ------ 2. Create biconomy smart account instance
const
smartAccount
=
await
createSmartAccountClient
(
{
signer
:
client
,
bundlerUrl
:
"https://bundler.biconomy.io/api/v2/80002/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44"
,
}
)
;
const
saAddress
=
await
smartAccount
.
getAccountAddress
(
)
;
console
.
log
(
"SA Address"
,
saAddress
)
;
// ------ 3. Generate transaction data
const
nftAddress
=
"0x1758f42Af7026fBbB559Dc60EcE0De3ef81f665e"
;
const
parsedAbi
=
parseAbi
(
[
"function safeMint(address _to)"
]
)
;
const
nftData
=
encodeFunctionData
(
{
abi
:
parsedAbi
,
functionName
:
"safeMint"
,
args
:
[
saAddress
as
Hex
]
,
}
)
;
// ------ 4. Send transaction
const
userOpResponse
=
await
smartAccount
.
sendTransaction
(
{
to
:
nftAddress
,
data
:
nftData
,
}
)
;
const
{
transactionHash
}
=
await
userOpResponse
.
waitForTxHash
(
)
;
console
.
log
(
"transactionHash"
,
transactionHash
)
;
const
userOpReceipt
=
await
userOpResponse
.
wait
(
)
;
if
(
userOpReceipt
.
success
==
"true"
)
{
console
.
log
(
"UserOp receipt"
,
userOpReceipt
)
;
console
.
log
(
"Transaction receipt"
,
userOpReceipt
.
receipt
)
;
}
}
;
createAccountAndMintNft
(
)
;
If you run into any errors, check out
troubleshooting
for common errors.
🎉
Congratulations on completing the quickstart!
Check out Tutorials
​
Explore the tutorials for various use cases.
Send a batch of transactions
​
In this you will do batching of transactions which is sending more than one transaction in an array and execute them with a single signature.
Send a gasless transaction
​
In this you will do a gasless transaction for which you will not have to pay any gas fees and with empty funds in your smart account you can execute transactions.
Pay gas in ERC20
​
In this you will execute a transaction by paying gas fees in ERC20 tokens, for this your smart account should have the specific ERC20 token for paying gas fees.
To dive deeper, check out more
use cases
.
Previous
Overview
Next
Tutorials
1. Setup 🛠️
2. Create a Smart Account 🌟
3. Execute your first transaction 🚀
Check out Tutorials
Send a batch of transactions
Send a gasless transaction
Pay gas in ERC20
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Tutorials | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Send a simple transaction
Send a batch of transactions
Send a gasless transaction
Pay gas in ERC20 tokens
Send parallel user ops
Sessions
Custom Validation Module
Migrating to V4
API integration
Utilities
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Tutorials
Version: SDK V4 (latest)
Tutorials
📄️
Send a simple transaction
Overview
📄️
Send a batch of transactions
Overview
📄️
Send a gasless transaction
Overview
📄️
Pay gas in ERC20 tokens
Overview
📄️
Send parallel user ops
Overview
🗃️
Sessions
5 items
📄️
Custom Validation Module
This section of the tutorial requires Solidity knowledge and smart contract development
📄️
Migrating to V4
This guide provides instructions for migrating from v3 to v4. It outlines the changes introduced in the new version and offers guidance on updating your codebase to ensure compatibility.
🗃️
API integration
4 items
🗃️
Utilities
2 items
Previous
Quickstart
Next
Send a simple transaction
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Integration | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Integration
Methods
APIs
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Bundler
Integration
Version: SDK V4 (latest)
On this page
Integration
This guide focuses on the code to integrate the Bundler. To see how this interacts with other packages in the sdk you can view the
Smart Accounts Integration page
.
Installation
​
First, install the required packages for initializing the Bundler and Smart Account.
npm
yarn
pnpm
npm install @biconomy/account
yarn add @biconomy/account
pnpm add @biconomy/account
Integration
​
info
Click here
to learn more about our dashboard and how to get your own bundler url.
To create a bundler instance pass the bundler url, with other optional params.
import
{
create
}
from
"@biconomy/account"
;
const
userOpReceiptMaxDurationIntervals
:
{
[
key
in
number
]
?
:
number
}
=
{
[
80002
]
:
60000
,
}
;
const
bundler
=
await
create
(
{
bundlerUrl
:
""
,
// <-- Read about this at https://docs.biconomy.io/dashboard#bundler-url
userOpReceiptMaxDurationIntervals
,
}
)
;
Parameters
bundlerUrl(
string
, required): bundler url from the dashboard
userOpReceiptIntervals
(
object
, optional): The polling interval per chain for the tx receipt in milliseconds. Default value is 5 seconds.
userOpWaitForTxHashIntervals
(
object
, optional): The polling interval per chain for the tx result in milliseconds. Default value is 0.5 seconds.
userOpReceiptMaxDurationIntervals
(
object
, optional): The maximum duration in milliseconds per chain to wait for the tx receipt. Default value is 30 seconds.
userOpWaitForTxHashMaxDurationIntervals
(
object
, optional): The maximum duration in milliseconds per chain to wait for the tx hash. Default value is 20 seconds.
returns
bundler
(
Promise<Bundler>
): bundler instance
Once initialized you will be able to pass this Bundler instance to the Smart Account configuration to use in conjunction with Smart Accounts. See our
tutorials
for in depth integrations of the Smart Account and Bundler.
Edit this page
Previous
Bundler
Next
Methods
Installation
Integration
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Methods | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Integration
Methods
APIs
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Bundler
Methods
Version: SDK V4 (latest)
On this page
Methods
estimateUserOpGas
​
This method is used to estimate gas for the userOp. It returns estimates for preVerificationGas, verificationGasLimit, and callGasLimit for a given UserOperation. It requires passing a semi-valid/ dummy signature in userOp (e.g. a signature of the correct length and format).
Usage
const
userOpGasResponse
:
UserOpGasResponse
=
await
bundler
.
estimateUserOpGas
(
userOp
)
;
Parameters
userOp(
UserOperationStruct
, required): userOperation to calculate gas for.
stateOverrideSet(
StateOverrideSet
): optional state override set for estimating gas for a userOperation under different blockchain states.
returns
userOpGasResponse(
Promise<UserOpGasResponse>
): It returns an object containing the following gas values.
type
UserOpGasResponse
=
{
preVerificationGas
:
string
;
verificationGasLimit
:
string
;
callGasLimit
:
string
;
maxPriorityFeePerGas
:
string
;
maxFeePerGas
:
string
;
}
;
sendUserOp
​
This method is used to execute the userOperation.
Usage
const
userOpResponse
:
UserOpResponse
=
await
bundler
.
sendUserOp
(
userOp
)
;
Parameters
userOp(
UserOperation
, required): userOperation to send.
simulationParam(
SimulationType
): The simulationType enum can be of two types:
validation
which will only simulate the validation phase, checks if user op is valid but does not check if execution will succeed. By default this flag is set to validation.
validation_and_execution
checks if user op is valid and if user op execution will succeed.
returns
userOpResponse(
Promise<UserOpResponse>
): It returns an object containing the userOpHash and other methods.
wait()
method waits for the receipt until the transaction is mined.
waitForTxHash()
returns transactionHash identifier (not userOpHash) and you can later watch for receipt on your own.
type
UserOpResponse
=
{
userOpHash
:
string
;
wait
(
_confirmations
?
:
number
)
:
Promise
<
UserOpReceipt
>
;
waitForTxHash
(
)
:
Promise
<
UserOpStatus
>
;
}
;
getUserOpReceipt
​
After using
sendUserOp
you will receive a
userOpResponse
which contains a string called
userOpHash
Using this
userOpHash
you can fetch the
userOpReceipt
which verifies that your
userOp
was handled on chain as a transaction.
Usage
const
userOpReceipt
=
await
bundler
.
getUserOpReceipt
(
"0x...."
)
;
Parameters
userOpHash(
string
, required): user operation hash.
returns
userOpReceipt(
Promise<UserOpReceipt>
): The full UserOpReceipt object type is shown below:
type
UserOpReceipt
=
{
actualGasCost
:
Hex
;
actualGasUsed
:
Hex
;
entryPoint
:
string
;
logs
:
any
[
]
;
paymaster
:
string
;
reason
:
string
;
receipt
:
UserOperationReceipt
[
"receipt"
]
;
success
:
"true"
|
"false"
;
userOpHash
:
string
;
}
;
getUserOpByHash
​
Using the
userOpHash
you can fetch the original
userOp
that was created with this hash.
Usage
const
userOp
=
await
bundler
.
getUserOpByHash
(
"0x..."
)
;
Parameters
userOpHash(
string
, required): user operation hash.
returns
userOp(
Promise<UserOpByHashResponse>
) : The userOperation will contain the following values:
type
BytesLike
=
Bytes
|
string
;
type
UserOpByHashResponse
=
UserOperationStruct
&
{
transactionHash
:
string
;
blockNumber
:
number
;
blockHash
:
string
;
entryPoint
:
string
;
}
;
type
UserOperationStruct
=
{
callData
:
BytesLike
;
callGasLimit
?
:
number
|
bigint
|
`
0x
${
string
}
`
;
initCode
:
BytesLike
;
maxFeePerGas
?
:
number
|
bigint
|
`
0x
${
string
}
`
;
maxPriorityFeePerGas
?
:
number
|
bigint
|
`
0x
${
string
}
`
;
nonce
:
number
|
bigint
|
`
0x
${
string
}
`
;
paymasterAndData
:
BytesLike
;
preVerificationGas
?
:
number
|
bigint
|
`
0x
${
string
}
`
;
sender
:
string
;
signature
:
BytesLike
;
verificationGasLimit
?
:
number
|
bigint
|
`
0x
${
string
}
`
;
}
;
Edit this page
Previous
Integration
Next
APIs
estimateUserOpGas
sendUserOp
getUserOpReceipt
getUserOpByHash
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

APIs | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Integration
Methods
APIs
Estimate UserOperation Gas
Send UserOperation
Get UserOperation Receipt
Get UserOperation by Hash
Get Chain ID
Get Supported Entry Points
Get gas fee values
Get UserOperation Status
API Explorer
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Bundler
APIs
Version: SDK V4 (latest)
APIs
You can get your Bundler URL from the Biconomy
Dashboard
.
This is the same endpoint URL used for all the networks.
All requests must follow the
JSON RPC
specifications.
info
This documentation is for using our Bundler API directly. If you are building with the Biconomy SDK you can follow the instructions on this
page
.
You can test these endpoints on our
Bundler Explorer
.
📄️
Estimate UserOperation Gas
eth_estimateUserOperationGas
📄️
Send UserOperation
eth_sendUserOperation
📄️
Get UserOperation Receipt
eth_getUserOperationReceipt
📄️
Get UserOperation by Hash
eth_getUserOperationByHash
📄️
Get Chain ID
eth_chainId
📄️
Get Supported Entry Points
eth_supportedEntryPoints
📄️
Get gas fee values
biconomy_getGasFeeValues
📄️
Get UserOperation Status
biconomy_getUserOperationStatus
📄️
API Explorer
You will need a Bundler URL from your dashboard to use the explorer. Create a userOp and paste it below to begin
Previous
Methods
Next
Estimate UserOperation Gas
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Integration | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Integration
Methods
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Gas Estimations SDK
Integration
Version: SDK V4 (latest)
On this page
Integration
This guide focuses on the code to integrate the entry point gas estimations package.
Installation
​
First, install the required packages for initializing the gas estimator client
npm
yarn
npm i entry-point-gas-estimations
yarn add entry-point-gas-estimations
Integration
​
import
{
createGasEstimator
}
from
"entry-point-gas-estimations"
;
// Creating a general gas estimator client
const
gasEstimator
=
createGasEstimator
(
{
rpcUrl
,
}
)
;
// L2s have a different way of calculating the preVerificationGas
// which requires creating network-specific gas estimator clients
// Optimism Stack Networks
const
optimismGasEstimator
=
createOptimismGasEstimator
(
{
rpcUrl
,
}
)
;
// Arbitrum Networks
const
arbitrumGasEstimator
=
createArbitrumGasEstimator
(
{
rpcUrl
,
}
)
;
// Mantle Networks
const
mantleGasEstimator
=
createMantleGasEstimator
(
{
rpcUrl
,
}
)
;
// Scroll Networks
const
scrollGasEstimator
=
createScrollGasEstimator
(
{
rpcUrl
,
}
)
;
Parameters
rpcUrl(
string
, required): RPC Url of the network
entryPointAddress(
string
): optional entry point if it is different than 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
returns
gasEstimator
(
Promise<GasEstimator>
): gas estimator instance
Edit this page
Previous
Gas Estimations SDK
Next
Methods
Installation
Integration
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Methods | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Integration
Methods
Modules
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Gas Estimations SDK
Methods
Version: SDK V4 (latest)
On this page
Methods
estimateUserOperationGas
​
This method is used to estimate gas for the userOp. It returns estimates for preVerificationGas, verificationGasLimit, and callGasLimit for a given UserOperation. It requires passing a semi-valid/ dummy signature in userOp (e.g. a signature of the correct length and format).
Usage
const
estimateUserOperationGasResponse
:
EstimateUserOperationGas
=
await
gasEstimator
.
estimateUserOperationGas
(
{
userOperation
,
supportsEthCallStateOverride
,
supportsEthCallByteCodeOverride
,
stateOverrideSet
baseFeePerGas
}
)
;
Parameters
userOperation(
UserOperation
, required): userOperation to calculate gas estimates for.
stateOverrideSet(
StateOverrideSet
): optional state override set for estimating gas for a userOperation under different blockchain states.
supportsEthCallStateOverride (
boolean
): optional param, default set to true, set to false if eth_call does not support state overrides
supportsEthCallByteCodeOverride (
boolean
): optional param, default set to true, set to false if eth_call does not give the correct response to bytecode overrides
baseFeePerGas (
bigint
): optional param, but required for Optimism based networks
returns
estimateUserOperationGasResponse(
Promise<EstimateUserOperationGas>
): It returns an object containing the following gas limits.
type
EstimateUserOperationGas
=
{
callGasLimit
:
bigint
;
verificationGasLimit
:
bigint
;
preVerificationGas
:
bigint
;
validAfter
:
number
;
validUntil
:
number
;
}
;
estimateVerificationGasLimit
​
This method is used to estimate the verificationGasLimit for a given userOperation.
Usage
const
verificationGasLimitResponse
:
EstimateVerificationGasLimit
=
await
gasEstimator
.
estimateVerificationGasLimit
(
{
userOperation
,
supportsEthCallStateOverride
,
supportsEthCallByteCodeOverride
,
stateOverrideSet
,
}
)
;
Parameters
userOperation(
UserOperation
, required): userOperation to calculate gas estimates for.
stateOverrideSet(
StateOverrideSet
): optional state override set for estimating gas for a userOperation under different blockchain states.
supportsEthCallStateOverride (
boolean
): optional param, default set to true, set to false if eth_call does not support state overrides
supportsEthCallByteCodeOverride (
boolean
): optional param, default set to true, set to false if eth_call does not give the correct response to bytecode overrides
returns
verificationGasLimitResponse(
Promise<EstimateVerificationGasLimit>
): It returns an object containing the verificationGasLimit, validUntil, and validAfter values
type
EstimateVerificationGasLimit
=
{
verificationGasLimit
:
bigint
;
validAfter
:
number
;
validUntil
:
number
;
}
;
estimateCallGasLimit
​
This method is used to estimate the callGasLimit for a given userOperation.
Usage
const
callGasLimitResponse
=
await
gasEstimator
.
estimateCallGasLimit
(
{
userOperation
,
supportsEthCallStateOverride
,
supportsEthCallByteCodeOverride
,
stateOverrideSet
,
}
)
;
Parameters
userOperation(
UserOperation
, required): userOperation to calculate gas estimates for.
stateOverrideSet(
StateOverrideSet
): optional state override set for estimating gas for a userOperation under different blockchain states.
supportsEthCallStateOverride (
boolean
): optional param, default set to true, set to false if eth_call does not support state overrides
supportsEthCallByteCodeOverride (
boolean
): optional param, default set to true, set to false if eth_call does not give the correct response to bytecode overrides
returns
callGasLimitResponse(
Promise<EstimateCallGasLimit>
): It returns an object containing the callGasLimit value
type
EstimateCallGasLimit
=
{
callGasLimit
:
bigint
;
}
;
calculatePreVerificationGas
​
This method is used to estimate the preVerificationGas for a given userOperation. The exact implementation of this method is network-dependent hence make sure to use network-specific gas estimator clients
Usage
const
preVerficationGasResponse
=
await
gasEstimator
.
calculatePreVerificationGas
(
{
userOperation
,
baseFeePerGas
,
}
)
;
Parameters
userOperation(
UserOperation
, required): userOperation to calculate gas estimates for.
baseFeePerGas (
bigint
): optional param, but required for Optimism based networks
returns
preVerificationGasResponse(
Promise<CalculatePreVerificationGas>
) : It returns an object containing the preVerficationGas value
type
CalculatePreVerificationGas
=
{
preVerificationGas
:
bigint
;
}
;
setEntryPointAddress
​
This method is used to set the entryPointAddress that is being used in the Gas Estimator instance
Usage
await
gasEstimator
.
setEntryPointAddress
(
"<ENTRY_POINT_ADDRESS>"
)
;
Parameters
entryPointAddress(
string
, required): entry point address that one might need to change to.
returns
void
Edit this page
Previous
Integration
Next
Modules
estimateUserOperationGas
estimateVerificationGasLimit
estimateCallGasLimit
calculatePreVerificationGas
setEntryPointAddress
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

ECDSA Ownership Module | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
ECDSA Ownership
Version: SDK V4 (latest)
On this page
ECDSA Ownership Module
What is it? 🤔
​
The
ECDSA Ownership Registry Module
or
ECDSA Validation Module
is integral to
Biconomy's Modular Smart Account
, enhancing transaction security and user authentication. This document outlines its functionality, benefits, and use cases.
What is the ECDSA Ownership Module? 🤔
​
This module allows
Externally Owned Accounts (EOAs)
to authorize and sign user operations (UserOps) for Smart Account. It operates similarly to non-modular Smart Account ownership but is reconstructed as a
Validation Module
within the
Account Abstraction + Modular Smart Accounts
ecosystem.
tip
The ECDSA Validation Module is the standard choice for Biconomy Modular Smart Accounts unless another module is chosen during setup. It makes things easier for users and helps manage ownership smoothly.
Key Functions 🔐
​
Single Signer Simplicity
: Offers 1/1 multisig, single-signature control, ideal for both Web2 users and crypto-native users who already possess an EOA wallet.
ECDSA Signature Scheme
: Utilizes the ECDSA secp256k1 curve for secure signing.
Flexible Owner Authentication
: Supports various signer solutions like Privy, Fireblocks, Arcana Auth, Web3Auth, Magic, Capsule, Turnkey or Particle.
EIP-1271 Compliance
: Allowing Smart Accounts to sign Ethereum messages for logging into dApps.
info
One of the most popular modules, it bridges the ease of traditional web logins with the security of blockchain technology.
Use Cases 🌟
​
Secure Transaction Signing
: EOAs can securely authorize transactions for Smart Accounts.
dApp Interaction
: Simplifies the process of logging into dApps using Ethereum messages thanks to EIP-1271 support.
Ownership Management
: Mirrors traditional ownership systems, providing a familiar framework within a more advanced blockchain setting.
SDK Guide 📘
​
Initializing ECDSA Module 🌟
​
There is no need to do anything in order to use ECDSAOwnershipValidationModule, this module is set by default on every smart account.
Usage
import
{
createECDSAOwnershipValidationModule
,
createSmartAccountClient
,
}
from
"@biconomy/accounts"
;
const
ecdsaModuleConfig
=
{
signer
}
;
const
defaultValidationModule
=
await
createECDSAOwnershipValidationModule
(
ecdsaModuleConfig
)
;
// Signer for smart account taken from the module
const
smartAccount
=
await
createSmartAccountClient
(
{
bundlerUrl
,
defaultValidationModule
,
// Alternatively this can be ommitted, as it is the default validation module used when accounts are created
}
)
;
const
saModuleAddress
=
await
smartAccount
.
activeValidationModule
.
getAddress
(
)
;
console
.
log
(
saModuleAddress
===
defaultValidationModule
.
moduleAddress
)
;
// true
Parameters
required params are explicitly mentioned
signer(
Signer
, required): Pass the signer instance into the validation module which gets used to detect owner of the smart account.
entryPointAddress(
Hex
): Defaults to
"0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789"
moduleAddress(
Hex
): Defaults to
"0x0000001c5b32F37F5beA87BDD5374eB2aC54eA8e"
version(ModuleVersion): Defaults to
"V1_0_0"
Returns
ecdsaOwnershipValidationModule
(
ECDSAOwnershipValidationModule
): An instance of the Biconomy ECDSA ownership validation module.
info
The Smart Account's address is counterfactually generated based on the signer's public key, which is the owner's address used in the ECDSA Module. This feature allows for the pre-calculation of the account address before deployment.
warning
To deploy the same Smart Account (with the same address) on different chains, it's crucial to use the same module address, the same initialization data (here, the owner's EOA address) for the ECDSA Module here and the index. This ensures consistency in the account's address across various blockchains.
Smart Contract Deep Dive 🛠️
​
This section dives into the
EcdsaOwnershipRegistryModule
for Biconomy Smart Accounts, focusing on key functionalities and security aspects.
Core Functionalities
​
User Operation Validation (
validateUserOp
) 🛡️
​
// Validates user operations signed by an EOA
function
validateUserOp
(
UserOperation
calldata
userOp
,
bytes32
userOpHash
)
external
view
virtual override
returns
(
uint256
)
{
if
(
_verifySignature
(
userOpHash
,
userOp
.
signature
[
96
:
161
]
,
userOp
.
sender
)
)
{
return
VALIDATION_SUCCESS
;
}
return
SIG_VALIDATION_FAILED
;
}
note
Objective: The function safeguards the authenticity of user operations on Smart Accounts.
Method: It specifically decodes and verifies a segment of the userOp.signature. This segmentation is crucial because userOp.signature contains both the signature and the validation module's address. By extracting only the signature part, the function accurately validates the operation against the intended owner's signature, ensuring that the operation is legitimately authorized.
Signature Verification (
_verifySignature
) 🔐
​
// Internal function to verify the signature of a smart account
function
_verifySignature
(
bytes32
dataHash
,
bytes
memory
signature
,
address
smartAccount
)
internal
view
returns
(
bool
)
{
address
expectedSigner
=
_smartAccountOwners
[
smartAccount
]
;
// Reverts if no owner is registered
if
(
expectedSigner
==
address
(
0
)
)
{
revert
NoOwnerRegisteredForSmartAccount
(
smartAccount
)
;
}
// Checks for signature length and recovers the signer
if
(
signature
.
length
<
65
)
revert
WrongSignatureLength
(
)
;
address
recovered
=
(
dataHash
.
toEthSignedMessageHash
(
)
)
.
recover
(
signature
)
;
if
(
expectedSigner
==
recovered
)
{
return
true
;
}
recovered
=
dataHash
.
recover
(
signature
)
;
return
expectedSigner
==
recovered
;
}
Validates a signature against a data hash and registered owner, supporting EIP-1271 standard.
function
isValidSignature
(
bytes32
dataHash
,
bytes
memory
signature
)
public
view
returns
(
bytes4
)
;
note
isValidSignature
serves as a key function for external smart contracts to verify signature authenticity.
caution
Proper handling and verification of signatures are crucial for maintaining the integrity of the Smart Account. The
isValidSignature
function is essential for EIP-1271 support, validating that the signature matches the expected signer as per the EIP-1271 standard.
Security Considerations
​
Strict Ownership Rules
: Only Externally Owned Accounts (EOAs) can authorize transactions, ensuring secure control over Smart Account operations.
Signature Verification
: Implements robust methods for signature validation, crucial for preventing unauthorized access.
info
The
initForSmartAccount
method doesn't include
isSmartContract
checks due to operational constraints. However, this doesn't compromise security as operations require valid EOA signatures. This ensures Smart Accounts remain secure within their operational framework.
Interaction with Smart Accounts 🤝
​
The
EcdsaOwnershipRegistryModule
interacts with Smart Accounts primarily through its core functionalities:
Initialization and Ownership
: During deployment, Smart Accounts use
init
method to invoke
initForSmartAccount
on modules, setting initial ownership and configurations.
User Operation Validation
: When a Smart Account attempts to perform an operation,
validateUserOp
is invoked to ensure the action is authorized by the registered owner.
Signature Verification
: The module uses
_verifySignature
to verify any signatures associated with transactions initiated by the Smart Account.
Previous
Modules
Next
Multichain Validation
What is it? 🤔
What is the ECDSA Ownership Module? 🤔
SDK Guide 📘
Initializing ECDSA Module 🌟
Smart Contract Deep Dive 🛠️
Core Functionalities
Security Considerations
Interaction with Smart Accounts 🤝
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Multichain Validation | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
Multichain Validation
Version: SDK V4 (latest)
On this page
Multichain Validation
This module acts as an extension of the
ECDSA Module
. The added benefit of this module is you now have the ability to sign once and authorize any number of userOps across multiple blockchain networks.
What is the Multichain Validation Module? 🤔
​
This module allows
Externally Owned Accounts (EOAs)
to authorize and sign user operations (UserOps) for Biconomy Smart Accounts on Multiple chains with a single ECDSA signature.
Benefits
Significantly improves UX for deploying and setting up Smart Accounts on several chains
Significantly reduces user friction for multichain operations.
tip
You can also use this module as the
default module
just like the ECDSA Validation Module, as it has all its capabilities for sending userOps on the particular chain.
Key Functions 🔐
​
ECDSA Signature Scheme
: Utilizes the ECDSA secp256r1 curve for secure signing.
Flexible Signer Authentication
: Supports various signer solutions like Privy, Fireblocks, Arcana Auth, Capsule, Lit protocol, Turnkey, Web3Auth, Particle, Magic, Portal, etc.
EIP-1271 Compliance
: Allowing Smart Accounts to sign Ethereum messages for logging into dApps.
Sign once, Execute on multiple chains
Use Cases 🌟
​
Enables use cases which require several actions to be authorized for several chains with just one signature required from user.
Multichain intent for example exit all my native tokens for USDC
Allows a dApp to require just one signature from their user to configure & deploy smart accounts on multiple chains and delegate certain actions with permission via session keys on all those chains
Cross-chain state sync actions e.g transfer ownership of a smart account, change ENS, similar actions on a protocol that are deployed on multiple chains
Onboard a user on x chains by deploying their smart account and some action like registering in a raffle
How does it work? 🤔
​
Collecting the set of userOps for signing
Calculate userOpHash
Every userOpHash is now a leaf of a Merkle Tree.
Instead of signing individual hashes, the user signs the Merkle Root.
Now this signed Merkle Root serves as on-chain evidence, proving any userOp within the tree is authorized. With this, Users can authorize any number of userOps with just one signature over the Merkle Tree Root.
Smart Contract Deep Dive 🛠️
​
You have the option to transmit a multi-chain signature, enabling the sending of various user operations on distinct chains. This signature is then validated by the module. Alternatively, if a plain ECDSA signature (65 bytes) is sent, the module interprets it as a standard ECDSA validation.
User Operation Validation (
validateUserOp
) 🛡️
​
function
validateUserOp
(
UserOperation
calldata
userOp
,
bytes32
userOpHash
)
external
view
virtual override
returns
(
uint256
)
{
(
bytes
memory
moduleSignature
,
)
=
abi
.
decode
(
userOp
.
signature
,
(
bytes
,
address
)
)
;
if
(
moduleSignature
.
length
==
65
)
{
return
_verifySignature
(
userOpHash
,
moduleSignature
,
address
(
uint160
(
sender
)
)
)
?
VALIDATION_SUCCESS
:
SIG_VALIDATION_FAILED
;
}
(
uint48
validUntil
,
uint48
validAfter
,
bytes32
merkleTreeRoot
,
bytes32
[
]
memory
merkleProof
,
bytes
memory
multichainSignature
)
=
abi
.
decode
(
moduleSignature
,
(
uint48
,
uint48
,
bytes32
,
bytes32
[
]
,
bytes
)
)
;
bytes32
leaf
=
keccak256
(
abi
.
encodePacked
(
validUntil
,
validAfter
,
userOpHash
)
)
;
if
(
!
MerkleProof
.
verify
(
merkleProof
,
merkleTreeRoot
,
leaf
)
)
{
revert
(
"Invalid UserOp"
)
;
}
return
_verifySignature
(
merkleTreeRoot
,
multichainSignature
,
address
(
uint160
(
sender
)
)
)
?
_packValidationData
(
false
,
validUntil
==
0
?
type
(
uint48
)
.
max
:
validUntil
,
validAfter
)
:
SIG_VALIDATION_FAILED
;
}
All the other methods are inherited from
ECDSAOwnershipRegistryModule
References
​
Source code
Merkle Trees
How to Guide - Biconomy SDK 📘
​
Integrate the Multichain Validation Module into Biconomy Smart Accounts using the SDK.
Setup and Installation
​
npm
yarn
pnpm
npm install @biconomy/account ethers
yarn add @biconomy/account ethers
pnpm add @biconomy/account ethers
Creating a Signer
​
import
{
ethers
}
from
"ethers"
;
const
provider
=
new
ethers
.
JsonRpcProvider
(
"[RPC_Endpoint]"
)
;
const
signer
=
new
ethers
.
Wallet
(
"[Private_Key]"
,
provider
)
;
Importing and Initializing Multichain Validation Module
​
import
{
createMultiChainValidationModule
,
DEFAULT_MULTICHAIN_MODULE
,
}
from
"@biconomy/account"
;
// Notice this is chain agnostic so same instance can be used on instances of Smart account API on different chains
const
multiChainModule
=
await
createMultiChainValidationModule
(
{
signer
:
signer
,
moduleAddress
:
DEFAULT_MULTICHAIN_MODULE
,
}
)
;
Once initialized it can be passed to the smart account
create method
to create instances of the smart account.
Check
Paymaster integration
and
Bundler integration
sections to create instances of them.
Here is how you can set up Smart Account instances accross multiple chains:
import
{
createSmartAccountClient
,
PaymasterMode
}
from
"@biconomy/account"
;
let
baseAccount
=
await
createSmartAccountClient
(
{
biconomyPaymasterApiKey
:
"https://docs.biconomy.io/dashboard/paymaster"
bundlerUrl
:
""
,
// <-- Read about this at https://docs.biconomy.io/dashboard#bundler-url
defaultValidationModule
:
multiChainModule
,
activeValidationModule
:
multiChainModule
,
}
)
;
let
polygonAccount
=
await
createSmartAccountClient
(
{
biconomyPaymasterApiKey
:
"https://docs.biconomy.io/dashboard/paymaster"
bundlerUrl
:
""
,
// <-- Read about this at https://docs.biconomy.io/dashboard#bundler-url
defaultValidationModule
:
multiChainModule
,
activeValidationModule
:
multiChainModule
,
}
)
;
Signing and Sending Multichain userOps
​
// This could be swap action, mint nft, transfer ownership, enable different module as such (check use cases above) which you intend to do on multiple chains
// You can also batch with providing just array of transactions
// If the smart account is not deployed it would be deployed as part of this transaction. No additional action needed in below payload
import
{
encodeFunctionData
,
parseAbi
}
from
"viem"
;
// Example of creating the callData for the transaction
// This could be swap action, mint NFT, transfer ownershi p, enable different module as such (check use cases above) which you intend to do on multiple chains
// You can also batch with providing just array of transactions
// If the smart account is not deployed it would be deployed as part of this transaction. No additional action needed in below payload
const
nftAddress
=
"0x1758f42Af7026fBbB559Dc60EcE0De3ef81f665e"
;
const
parsedAbi
=
parseAbi
(
[
"function safeMint(address _to)"
]
)
;
const
mintNFTCallData
=
encodeFunctionData
(
{
abi
:
parsedAbi
,
functionName
:
"safeMint"
,
args
:
[
await
polygonAccount
.
getAddress
(
)
]
,
}
)
;
const
transaction
=
{
to
:
nftAddress
,
data
:
mintNFTCallData
,
}
;
// Build partial userOp for chain1
let
partialUserOp1
=
await
baseAccount
.
buildUserOp
(
[
transaction
]
,
{
// Assuming Sponsorship Paymaster is to be used otherwise leave as it's optional
paymasterServiceData
:
{
mode
:
PaymasterMode
.
SPONSORED
,
}
,
}
)
;
// Build partial userOp for chain2
let
partialUserOp2
=
await
polygonAccount
.
buildUserOp
(
[
transaction
]
,
{
// Assuming Sponsorship Paymaster is to be used otherwise leave as it's optional
paymasterServiceData
:
{
mode
:
PaymasterMode
.
SPONSORED
,
}
,
}
)
;
// Use multichain module to sign once for all ops
const
returnedOps
=
await
multiChainModule
.
signUserOps
(
[
{
userOp
:
partialUserOp1
,
chainId
:
84531
}
,
{
userOp
:
partialUserOp2
,
chainId
:
80002
}
,
]
)
;
const
userOpResponse1
=
await
baseAccount
.
sendSignedUserOp
(
returnedOps
[
0
]
as
any
)
;
// You can also just wait for transaction hash by waitForTxHash()
const
transactionDetails1
=
await
userOpResponse1
.
wait
(
)
;
const
userOpResponse2
=
await
polygonAccount
.
sendSignedUserOp
(
returnedOps
[
1
]
as
any
)
;
const
transactionDetails2
=
await
userOpResponse2
.
wait
(
)
;
info
When the Smart Account isn't yet deployed, setting
multiChainModule
as the default validation module is beneficial. This activates it by default and retains all functions of the
ECDSA Module
, a popular go-to module.
Conclusion
​
It makes it easier for dApps to deploy and set up Smart Accounts across multiple chains or issue session keys with different permissions for each chain, reducing user difficulties.
Multichain module allows us to use session keys and setup sessions on multiple chains with single wallet signature.
—
Rage Trade
Previous
ECDSA Ownership
Next
Session Key Manager
What is the Multichain Validation Module? 🤔
How does it work? 🤔
Smart Contract Deep Dive 🛠️
How to Guide - Biconomy SDK 📘
Setup and Installation
Creating a Signer
Importing and Initializing Multichain Validation Module
Signing and Sending Multichain userOps
Conclusion
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Session Key Manager | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
Session Key Manager
Version: SDK V4 (latest)
On this page
Session Key Manager
This module enables the use of sessions with session validation modules. The session validation modules can be deployed at different addresses. The validation modules themselves do not get implemented as modules themselves as they will all be managed by Session Key Manager.
Installation
​
npm
yarn
pnpm
npm install @biconomy/modules
yarn add @biconomy/modules
pnpm add @biconomy/modules
Integration
​
const
sessionModule
=
await
createSessionKeyManagerModule
(
{
moduleAddress
:
DEFAULT_SESSION_KEY_MANAGER_MODULE
,
smartAccountAddress
:
address
,
}
)
;
For full implementation see this
guide
Previous
Multichain Validation
Next
Batched Session Validation
Installation
Integration
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Batched Session Validation | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
Batched Session Validation
Version: SDK V4 (latest)
On this page
Batched Session Validation
This module works hand in hand with the Session Key Manager Module. It allows for multiple session validation modules to be activated for a user.
What it enables
​
Those who are familiar with the Biconomy Modular Session Keys framework know that it provides great flexibility and allows for quick building of the Session Validation Modules for every new use case without touching the core Session Keys logic. Batched Session Router adds composability, allowing batching of several session key signed operations which should be validated by different Session Validation modules into one User Operation and execute them atomically.
UX Impact
​
This module allows batching several operations (actions) into one atomically executed User Operation, thus ensuring better UX for many DeFi use cases.
Let’s take a very simple example. Some dApp wants to allow users to perform a simple flow of actions:
Approve token A to a DEX
Swap token A for token B
Stake token B on some Protocol
It also doesn’t want to make this on behalf of the users when the rate of the swap is optimal.
In this case, they will use Session Keys to sign those operations. Since those actions are very common there already are the building blocks for this = appropriate Session Validation Modules (SVMs): ERC20ApprovalSVM, DEXSwapSVM, ProtocolERC20StakeSVM.
Each of those SVMs is only able to validate userOps which specifically performs a given action: swap, approve, or stake. So none of them is able to validate the userOp which leverages executeBatch() method to perform those 3 actions together.
Of course, we can always build 3 separate userOps for those 3 actions, however, they won’t be included in the same bundle as per ERC-4337 specification, so they end up on 3 different bundles, and that’s not what the user wants in DeFi.
It’s also possible to build a custom Session Validation Module that works with this specific flow and validates such atomic userOps which leverages executeBatch(). However, if in the future there’s a need to add one more step to this flow, this will require a new Session Validation Module to be built. Such an SVM would also double-use some of the code already implemented in the basic SVMs and that is not a good practice. Also, this would require permissions to be separately set up for every new SVM.
Session Router addresses those issues by parsing executeBatch() calldata and routing validation flow to the specific SVMs based on the actions into the batch.
Now, dApps can construct flows based on the actions validated by basic SVMs and share common permissions across flows.
How it works
​
Batched Session Router leverages
SmartAccount.executeBatch()
method to execute atomic operations.
It is a Validation module, that validates the
userOps
with the
callData
field containing a call to
SmartAccount.executeBatch()
.
Every operation in the batch is expected to be an action managed by a specific Session Validation Module.
Of course, this action should be permitted for a given session key by enabling the appropriate session key + parameters in the Session Key Manager module.
So, the Batched Session Router
Verifies every action this userOp claims to perform is enabled for a given Smart Account.
Checks which Session Key was used to sign the userOp.
Checks this is the actual signer who is allowed to perform the actions.
Parses the executeBatch() calldata to get the per-action calldatas and passes them to the appropriate Session Validation Module. SVMs perform permissions checks to ensure that actions that are about to be performed with this calldata comply with the permissions.
It also intersects validity timeframes for all the enabled sessions. if at least one session is expired or not due, the whole atomic operation fails to be validated.
Installation
​
npm
yarn
pnpm
npm install @biconomy/account
yarn add @biconomy/account
pnpm add @biconomy/account
Integration
​
Integration is the same as using the Session Key Manager Module with the additional step of starting a session router module.
import
{
createSessionKeyManagerModule
,
createBatchedSessionRouterModule
,
DEFAULT_BATCHED_SESSION_ROUTER_MODULE
,
}
from
"@biconomy/account"
;
const
sessionModule
=
await
createSessionKeyManagerModule
(
{
moduleAddress
:
DEFAULT_SESSION_KEY_MANAGER_MODULE
,
smartAccountAddress
:
address
,
}
)
;
const
sessionRouterModule
=
await
createBatchedSessionRouterModule
(
{
moduleAddress
:
DEFAULT_BATCHED_SESSION_ROUTER_MODULE
,
sessionKeyManagerModule
:
sessionModule
,
smartAccountAddress
:
saAddress
,
}
)
;
Implementation of this is similar to the Session Key Manager module guide - a full implementation example is shown
here
Previous
Session Key Manager
Next
ABI Session Validation Module
What it enables
UX Impact
How it works
Installation
Integration
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

ABI Session Validation Module | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
ECDSA Ownership
Multichain Validation
Session Key Manager
Batched Session Validation
ABI Session Validation Module
Dashboard
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Modules
ABI Session Validation Module
Version: SDK V4 (latest)
On this page
ABI Session Validation Module
Diving into the
ABI Session Validation Module
, we explore its significance and interaction with the
Session Key Manager Module
via SDK.
note
Understanding the
ABI Session Validation Module
is crucial for leveraging
session keys
effectively in blockchain applications.
The Purpose of Session Validation Modules
​
At the core, an ABI Session Validation Module is a smart contract designed to authenticate whether a user's operation complies with the permissions set within a session key. It functions to validate user operations based on pre-defined session key permissions.
info
Key Functionality
: We'll dissect a deployed contract that validates permissions any type of smart contract logic, enabling dApps to execute transactions without user signatures every time.
Check the contract
here
.
Breaking Down the Contract
​
The smart contract we focus on is structured to validate user operations (userOps) for any smart contract using session key signatures. It's not tailored for a specific type of smart contract, we can declare rules and permissions for any contract method.
warning
Technical Deep Dive
: The following contract breakdown is technical in nature, aimed at developers with a solid understanding of smart contract functionalities.
// SPDX-License-Identifier: MIT
pragma solidity
^
0.8
.23
;
import
{
ECDSA
}
from
"@openzeppelin/contracts/utils/cryptography/ECDSA.sol"
;
import
"./ISessionValidationModule.sol"
;
/**
*
@title
ABI Session Validation Module for Biconomy Smart Accounts.
*
@dev
Validates userOps for any contract / method / params.
* The _sessionKeyData layout:
* Offset (in bytes)
| Length (in bytes) | Contents
* 0x0
| 0x14
| Session key (address)
* 0x14
| 0x14
| Permitted destination contract (address)
* 0x28
| 0x4
| Permitted selector (bytes4)
* 0x2c
| 0x10
| Permitted value limit (uint128)
* 0x3c
| 0x2
| Rules list length (uint16)
* 0x3e + 0x23*N
| 0x23
| Rule #N
*
* Rule layout:
* Offset (in bytes)
| Length (in bytes) | Contents
* 0x0
| 0x2
| Offset (uint16)
* 0x2
| 0x1
| Condition (uint8)
* 0x3
| 0x20
| Value (bytes32)
*
* Condition is a uint8, and can be one of the following:
* 0: EQUAL
* 1: LESS_THAN_OR_EQUAL
* 2: LESS_THAN
* 3: GREATER_THAN_OR_EQUAL
* 4: GREATER_THAN
* 5: NOT_EQUAL
*
* Inspired by https://github.com/zerodevapp/kernel/blob/main/src/validator/SessionKeyValidator.sol
*/
contract ABISessionValidationModule
is
ISessionValidationModule
{
uint256
private
constant
RULE_LENGTH
=
35
;
uint256
private
constant
SELECTOR_LENGTH
=
4
;
/**
*
@dev
validates if the _op (UserOperation) matches the SessionKey permissions
* and that _op has been signed by this SessionKey
* Please mind the decimals of your exact token when setting maxAmount
*
@param
_op
User Operation to be validated.
*
@param
_userOpHash
Hash of the User Operation to be validated.
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
*
@param
_sessionKeySignature
Signature over the the _userOpHash.
*
@return
true if the _op is valid, false otherwise.
*/
function
validateSessionUserOp
(
UserOperation calldata _op
,
bytes32 _userOpHash
,
bytes calldata _sessionKeyData
,
bytes calldata _sessionKeySignature
)
external pure override
returns
(
bool
)
{
bytes calldata callData
=
_op
.
callData
;
require
(
bytes4
(
callData
[
0
:
4
]
)
==
EXECUTE_OPTIMIZED_SELECTOR
||
bytes4
(
callData
[
0
:
4
]
)
==
EXECUTE_SELECTOR
,
"ABISV Not Execute Selector"
)
;
uint160 destContract
;
uint256 callValue
;
bytes calldata data
;
assembly
{
//offset of the first 32-byte arg is 0x4
destContract
:
=
calldataload
(
add
(
callData
.
offset
,
SELECTOR_LENGTH
)
)
//offset of the second 32-byte arg is 0x24 = 0x4 (SELECTOR_LENGTH) + 0x20 (first 32-byte arg)
callValue
:
=
calldataload
(
add
(
callData
.
offset
,
0x24
)
)
//we get the data offset from the calldata itself, so no assumptions are made about the data layout
let
dataOffset
:
=
add
(
add
(
callData
.
offset
,
0x04
)
,
//offset of the bytes arg is stored after selector and two first 32-byte args
// 0x4+0x20+0x20=0x44
calldataload
(
add
(
callData
.
offset
,
0x44
)
)
)
let
length
:
=
calldataload
(
dataOffset
)
//data itself starts after the length which is another 32bytes word, so we add 0x20
data
.
offset
:
=
add
(
dataOffset
,
0x20
)
data
.
length
:
=
length
}
return
_validateSessionParams
(
address
(
destContract
)
,
callValue
,
data
,
_sessionKeyData
)
==
ECDSA
.
recover
(
ECDSA
.
toEthSignedMessageHash
(
_userOpHash
)
,
_sessionKeySignature
)
;
}
/**
*
@dev
validates that the call (destinationContract, callValue, funcCallData)
* complies with the Session Key permissions represented by sessionKeyData
*
@param
destinationContract
address of the contract to be called
*
@param
callValue
value to be sent with the call
*
@param
_funcCallData
the data for the call. is parsed inside the SVM
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
* param _callSpecificData additional data, specific to the call, not used here
*
@return
sessionKey address of the sessionKey that signed the userOp
* for example to store a list of allowed tokens or receivers
*/
function
validateSessionParams
(
address destinationContract
,
uint256 callValue
,
bytes calldata _funcCallData
,
bytes calldata _sessionKeyData
,
bytes memory
/*_callSpecificData*/
)
external pure virtual override
returns
(
address
)
{
return
_validateSessionParams
(
destinationContract
,
callValue
,
_funcCallData
,
_sessionKeyData
)
;
}
/**
*
@dev
validates that the call (destinationContract, callValue, funcCallData)
* complies with the Session Key permissions represented by sessionKeyData
*
@param
destinationContract
address of the contract to be called
*
@param
callValue
value to be sent with the call
*
@param
_funcCallData
the data for the call. is parsed inside the SVM
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
*
@return
sessionKey address of the sessionKey that signed the userOp
* for example to store a list of allowed tokens or receivers
*/
function
_validateSessionParams
(
address destinationContract
,
uint256 callValue
,
bytes calldata _funcCallData
,
bytes calldata _sessionKeyData
)
internal pure virtual
returns
(
address
)
{
// every address is 20bytes
address sessionKey
=
address
(
bytes20
(
_sessionKeyData
[
0
:
20
]
)
)
;
address permittedDestinationContract
=
address
(
bytes20
(
_sessionKeyData
[
20
:
40
]
)
)
;
// every selector is 4bytes
bytes4 permittedSelector
=
bytes4
(
_sessionKeyData
[
40
:
44
]
)
;
// value limit is encoded as uint128 which is 16 bytes length
uint256 permittedValueLimit
=
uint256
(
uint128
(
bytes16
(
_sessionKeyData
[
44
:
60
]
)
)
)
;
// rules list length is encoded as uint16 which is 2 bytes length
uint256 rulesListLength
=
uint256
(
uint16
(
bytes2
(
_sessionKeyData
[
60
:
62
]
)
)
)
;
if
(
destinationContract
!=
permittedDestinationContract
)
{
revert
(
"ABISV Destination Forbidden"
)
;
}
if
(
bytes4
(
_funcCallData
[
0
:
4
]
)
!=
permittedSelector
)
{
revert
(
"ABISV Selector Forbidden"
)
;
}
if
(
callValue
>
permittedValueLimit
)
{
revert
(
"ABISV Permitted Value Exceeded"
)
;
}
// avoided explicit check that (_sessionKeyData.length - 62) is the multiple of RULE_LENGTH
// also avoided calculating the rules list length from the rules list itself
// both to save on gas
// there is a test case that demonstrates that if the incorrect rules list length is provided
// the validation will fail
if
(
!
_checkRulesForPermission
(
_funcCallData
,
rulesListLength
,
bytes
(
_sessionKeyData
[
62
:
]
)
//the rest of the _sessionKeyData is the rules list
)
)
{
revert
(
"ABISV Arg Rule Violated"
)
;
}
return
sessionKey
;
}
/**
*
@dev
checks if the calldata matches the permission
*
@param
data
the data for the call. is parsed inside the SVM
*
@param
rulesListLength
the length of the rules list
*
@param
rules
the rules list
*
@return
true if the calldata matches the permission, false otherwise
*/
function
_checkRulesForPermission
(
bytes calldata data
,
uint256 rulesListLength
,
bytes calldata rules
)
internal pure
returns
(
bool
)
{
for
(
uint256 i
;
i
<
rulesListLength
;
++
i
)
{
(
uint256 offset
,
uint256 condition
,
bytes32 value
)
=
_parseRule
(
rules
,
i
)
;
// get the 32bytes word to verify against reference value from the actual calldata of the userOp
bytes32 param
=
bytes32
(
data
[
SELECTOR_LENGTH
+
offset
:
SELECTOR_LENGTH
+
offset
+
32
]
)
;
bool rulePassed
;
assembly
(
"memory-safe"
)
{
switch
condition
case
0
{
// Condition.EQUAL
rulePassed
:
=
eq
(
param
,
value
)
}
case
1
{
// Condition.LESS_THAN_OR_EQUAL
rulePassed
:
=
or
(
lt
(
param
,
value
)
,
eq
(
param
,
value
)
)
}
case
2
{
// Condition.LESS_THAN
rulePassed
:
=
lt
(
param
,
value
)
}
case
3
{
// Condition.GREATER_THAN_OR_EQUAL
rulePassed
:
=
or
(
gt
(
param
,
value
)
,
eq
(
param
,
value
)
)
}
case
4
{
// Condition.GREATER_THAN
rulePassed
:
=
gt
(
param
,
value
)
}
case
5
{
// Condition.NOT_EQUAL
rulePassed
:
=
iszero
(
eq
(
param
,
value
)
)
}
}
if
(
!
rulePassed
)
{
return
false
;
}
}
return
true
;
}
/**
*
@dev
Parses a rule with a given index from the rules list
*
@param
rules
the rules list as a bytes array
*
@param
index
the index of the rule to be parsed
*
@return
offset - the offset of the parameter in the calldata (multiplier of 32)
*
@return
condition - the condition to be checked
*
@return
value - the reference value to be checked against
*/
function
_parseRule
(
bytes calldata rules
,
uint256 index
)
internal pure
returns
(
uint256 offset
,
uint256 condition
,
bytes32 value
)
{
// offset length is 2 bytes
offset
=
uint256
(
uint16
(
bytes2
(
rules
[
index
*
RULE_LENGTH
:
index
*
RULE_LENGTH
+
2
]
)
)
)
;
// condition length is 1 byte
condition
=
uint256
(
uint8
(
bytes1
(
rules
[
index
*
RULE_LENGTH
+
2
:
index
*
RULE_LENGTH
+
3
]
)
)
)
;
// value length is 32 bytes
value
=
bytes32
(
rules
[
index
*
RULE_LENGTH
+
3
:
index
*
RULE_LENGTH
+
RULE_LENGTH
]
)
;
}
}
The contract, extending the
ISessionValidationModule
interface, contains essential functions like
validateSessionUserOp
and
validateSessionParams
, each serving distinct roles in operation validation.
Solidity Contract Breakdown
​
Here's the Solidity contract in question:
Function Analysis:
validateSessionUserOp
​
note
This function is essential for
validating user operations
against
session key permissions
and ensuring they are correctly signed.
/**
*
@dev
validates if the _op (UserOperation) matches the SessionKey permissions
* and that _op has been signed by this SessionKey
* Please mind the decimals of your exact token when setting maxAmount
*
@param
_op
User Operation to be validated.
*
@param
_userOpHash
Hash of the User Operation to be validated.
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
*
@param
_sessionKeySignature
Signature over the the _userOpHash.
*
@return
true if the _op is valid, false otherwise.
*/
function
validateSessionUserOp
(
UserOperation calldata _op
,
bytes32 _userOpHash
,
bytes calldata _sessionKeyData
,
bytes calldata _sessionKeySignature
)
external pure override
returns
(
bool
)
{
bytes calldata callData
=
_op
.
callData
;
require
(
bytes4
(
callData
[
0
:
4
]
)
==
EXECUTE_OPTIMIZED_SELECTOR
||
bytes4
(
callData
[
0
:
4
]
)
==
EXECUTE_SELECTOR
,
"ABISV Not Execute Selector"
)
;
uint160 destContract
;
uint256 callValue
;
bytes calldata data
;
assembly
{
//offset of the first 32-byte arg is 0x4
destContract
:
=
calldataload
(
add
(
callData
.
offset
,
SELECTOR_LENGTH
)
)
//offset of the second 32-byte arg is 0x24 = 0x4 (SELECTOR_LENGTH) + 0x20 (first 32-byte arg)
callValue
:
=
calldataload
(
add
(
callData
.
offset
,
0x24
)
)
//we get the data offset from the calldata itself, so no assumptions are made about the data layout
let
dataOffset
:
=
add
(
add
(
callData
.
offset
,
0x04
)
,
//offset of the bytes arg is stored after selector and two first 32-byte args
// 0x4+0x20+0x20=0x44
calldataload
(
add
(
callData
.
offset
,
0x44
)
)
)
let
length
:
=
calldataload
(
dataOffset
)
//data itself starts after the length which is another 32bytes word, so we add 0x20
data
.
offset
:
=
add
(
dataOffset
,
0x20
)
data
.
length
:
=
length
}
return
_validateSessionParams
(
address
(
destContract
)
,
callValue
,
data
,
_sessionKeyData
)
==
ECDSA
.
recover
(
ECDSA
.
toEthSignedMessageHash
(
_userOpHash
)
,
_sessionKeySignature
)
;
}
Execution Steps:
Match Function Selectors:
This step ensures that the calldata of a given user operation calls the function with the allowed selectors only.
In this method, it checks whether the first four bytes of the call data match predefined selectors (EXECUTE_OPTIMIZED_SELECTOR or EXECUTE_SELECTOR).
Decode Session Key Data:
Here, the essential details from the session key data are extracted to understand the permissions and constraints associated with the user operation.
This includes retrieving information such as the destination contract, call value, and additional data from the call data provided in the user operation.
Verify Operation Details:
This step validates the details of the user operation against the permissions specified by the session key.
It checks whether the call data aligns with the permissions specified in the session key data.
Additionally, it ensures that any constraints or limits imposed by the session key, such as maximum transaction amounts or permitted recipients, are respected.
Signature Validation:
In this final step, the method confirms the authenticity of the operation by verifying its signature against the session key.
ECDSA (Elliptic Curve Digital Signature Algorithm) is used to validate that the provided signature matches the session key.
If the signature verification is successful, it indicates that the operation has been correctly signed by the session key.
Function Analysis:
validateSessionParams
​
/**
*
@dev
validates that the call (destinationContract, callValue, funcCallData)
* complies with the Session Key permissions represented by sessionKeyData
*
@param
destinationContract
address of the contract to be called
*
@param
callValue
value to be sent with the call
*
@param
_funcCallData
the data for the call. is parsed inside the SVM
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
* param _callSpecificData additional data, specific to the call, not used here
*
@return
sessionKey address of the sessionKey that signed the userOp
* for example to store a list of allowed tokens or receivers
*/
function
validateSessionParams
(
address destinationContract
,
uint256 callValue
,
bytes calldata _funcCallData
,
bytes calldata _sessionKeyData
,
bytes memory
/*_callSpecificData*/
)
external pure virtual override
returns
(
address
)
{
return
_validateSessionParams
(
destinationContract
,
callValue
,
_funcCallData
,
_sessionKeyData
)
;
}
/**
*
@dev
validates that the call (destinationContract, callValue, funcCallData)
* complies with the Session Key permissions represented by sessionKeyData
*
@param
destinationContract
address of the contract to be called
*
@param
callValue
value to be sent with the call
*
@param
_funcCallData
the data for the call. is parsed inside the SVM
*
@param
_sessionKeyData
SessionKey data, that describes sessionKey permissions
*
@return
sessionKey address of the sessionKey that signed the userOp
* for example to store a list of allowed tokens or receivers
*/
function
_validateSessionParams
(
address destinationContract
,
uint256 callValue
,
bytes calldata _funcCallData
,
bytes calldata _sessionKeyData
)
internal pure virtual
returns
(
address
)
{
// every address is 20bytes
address sessionKey
=
address
(
bytes20
(
_sessionKeyData
[
0
:
20
]
)
)
;
address permittedDestinationContract
=
address
(
bytes20
(
_sessionKeyData
[
20
:
40
]
)
)
;
// every selector is 4bytes
bytes4 permittedSelector
=
bytes4
(
_sessionKeyData
[
40
:
44
]
)
;
// value limit is encoded as uint128 which is 16 bytes length
uint256 permittedValueLimit
=
uint256
(
uint128
(
bytes16
(
_sessionKeyData
[
44
:
60
]
)
)
)
;
// rules list length is encoded as uint16 which is 2 bytes length
uint256 rulesListLength
=
uint256
(
uint16
(
bytes2
(
_sessionKeyData
[
60
:
62
]
)
)
)
;
if
(
destinationContract
!=
permittedDestinationContract
)
{
revert
(
"ABISV Destination Forbidden"
)
;
}
if
(
bytes4
(
_funcCallData
[
0
:
4
]
)
!=
permittedSelector
)
{
revert
(
"ABISV Selector Forbidden"
)
;
}
if
(
callValue
>
permittedValueLimit
)
{
revert
(
"ABISV Permitted Value Exceeded"
)
;
}
// avoided explicit check that (_sessionKeyData.length - 62) is the multiple of RULE_LENGTH
// also avoided calculating the rules list length from the rules list itself
// both to save on gas
// there is a test case that demonstrates that if the incorrect rules list length is provided
// the validation will fail
if
(
!
_checkRulesForPermission
(
_funcCallData
,
rulesListLength
,
bytes
(
_sessionKeyData
[
62
:
]
)
//the rest of the _sessionKeyData is the rules list
)
)
{
revert
(
"ABISV Arg Rule Violated"
)
;
}
return
sessionKey
;
}
Operational Flow:
The method internally calls
_validateSessionParams
to perform the validation against the session permissions.
It passes the necessary parameters to
_validateSessionParams
and returns the result.
_validateSessionParams
validates the parameters of the call against the permissions defined for the session key.
**Execution flow in **_validateSessionParams****
Extracts essential details from _sessionKeyData, such as session key address, permitted destination contract, permitted method selector, value limit, and rules list length.
Checks if the destinationContract matches the permitted destination contract, if the function selector in _funcCallData matches the permitted selector, and if the callValue does not exceed the permitted value limit.
Calls
_checkRulesForPermission
to verify if the call data complies with the permission rules.
**Execution flow in **_checkRulesForPermission****
Iterates through the list of rules.
Parses each rule to determine the offset, condition, and value.
Verifies if the call data arguments satisfy conditions defined by the rules.
Rules
​
Rules define permissions for the args of an allowed method.
With rules, you can precisely define what should be the args of the transaction that is allowed for a given Session.
Every Rule works with a single static arg or a 32-byte chunk of the dynamic arg.
Since the ABI Encoding translates every static param into a 32-bytes word, even the shorter ones (like
address
or
uint8
), every Rule defines a desired relation (
Condition
) between n-th 32bytes word of the
calldata
and a reference Value (that is obviously a 32-bytes word as well).
So, when dApp is creating a
_sessionKeyData
to enable a session, it should convert every shorter static arg to a 32bytes word to match how it will be actually ABI encoded in the
userOp.callData
.
For the dynamic args, like
bytes
, every 32-bytes word of the
calldata
such as offset of the bytes arg, length of the bytes arg, and n-th 32-bytes word of the bytes arg can be controlled by a dedicated Rule.
Offset
The offset in the ABI SVM contract helps locate the relevant data within the function call data, it serves as a reference point from which to start reading or extracting specific information required for validation.
When processing function call data, particularly in low-level languages like Solidity assembly, it's necessary to locate where specific parameters or arguments are stored.
The offset is used to calculate the starting position within the
calldata
where the desired data resides.
Suppose we have a function call with multiple arguments passed as
calldata
. Each argument occupies a certain number of bytes, and the offset helps determine where each argument begins within the
calldata
.
Using the offset to Extract Data:
In the contract, the offset is used to calculate the position within the
calldata
where specific parameters or arguments are located. Since every arg is a 32-bytes word, offsets are always multiplier of 32 (or of 0x20 in hex).
Let's see how the offset is applied to extract the to and value arguments of a transfer(address to, uint256 value) method:
Extracting to Argument:
The to argument is the first parameter of the transfer function, representing the recipient address. Every
calldata
starts with the 4-bytes method selector. However, the ABI SVM is adding the selector length itself, so for the first argument the offset will always be 0 (0x00);
Extracting value Argument:
The value argument is the second parameter of the transfer function, representing the amount of tokens to be transferred. To extract this argument, the offset for the value parameter would be calculated based on its position in the function
calldata
. Despite to is a 20-bytes address, in the solidity abi encoding it is always appended with zeroes to a 32-bytes word. So the offset for the second 32-bytes argument (which isthe value in our case) will be 32 (or 0x20 in hex).
If you need to deal with dynamic-length arguments, such as bytes, please refer to this document
https://docs.soliditylang.org/en/v0.8.24/abi-spec.html#function-selector-and-argument-encoding
to learn more about how dynamic arguments are represented in the
calldata
and which offsets should be used to access them.
Condition
The condition is used to determine how we are checking the actual reference value, the condition can be of many types:
0: EQUAL
1: LESS_THAN_OR_EQUAL
2: LESS_THAN
3: GREATER_THAN_OR_EQUAL
4: GREATER_THAN
5: NOT_EQUAL
In our example the condition is 0, this means we check that the receiver of the NFT is EQUAL to what we set it to be.
Value
This is the reference value. The actual arg value is decoded from the userOp.callData using the Offset. Then it is compared to the reference value using the Condition.
Both
validateSessionUserOp
and
validateSessionParams
are integral to our dApp's security framework, ensuring strict adherence to permissions and enhancing transaction integrity.
Previous
Batched Session Validation
Next
Dashboard
The Purpose of Session Validation Modules
Breaking Down the Contract
Solidity Contract Breakdown
Function Analysis:
validateSessionUserOp
Function Analysis:
validateSessionParams
Rules
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Create a Paymaster | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Create a Paymaster
Version: SDK V4 (latest)
On this page
Create a Paymaster
Add Paymaster
​
Once you log in to our dashboard, you'll be directed to the paymaster page. To add a paymaster, simply click the "Add Paymaster" button.
Register Paymaster
​
After clicking the "Add Paymaster" button, you can register the paymaster. Give it a name, choose a version (currently 1.0.0), and select your preferred chain.
Create Gas Tank
​
If you want to sponsor users' transactions to make them gasless, you'll need to set up a gas tank.
On the Gas Tank page, which you'll see for the first time, note the wallet you use for the initial setup. This wallet is the only one authorized to withdraw funds from the gas tank. When you click "I understand and set up gas tank," your wallet will prompt you for a signature. This action incurs some gas costs. Congratulations!
Your gas tank is now set up.
Deposit Funds
​
Now that your gas tank is set up, you can deposit funds into it. Choose an amount and click "Deposit" to fill up your tank. Once the transaction is confirmed, you'll be able to see the available funds in your gas tank.
You can programmatically deposit funds using the paymasterContract
depositFor
function by passing the
amount
and
paymasterId
which is the EOA address. For instance, you can invoke the following
function
on the Polygon chain.
Withdraw funds
​
If you need to withdraw funds from your gas tank at any time, go to the gas tank page. Enter the desired withdrawal amount and click the "Withdraw" button.
info
Reminder that only the wallet you initially set up the gas tank with can actually perform a withdrawal. Any wallet is allowed to deposit as needed.
Previous
Dashboard
Next
Paymaster Rules
Add Paymaster
Register Paymaster
Create Gas Tank
Deposit Funds
Withdraw funds
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Paymaster Rules | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Paymaster Rules
Version: SDK V4 (latest)
On this page
Paymaster Rules
For a paymaster, you can restrict the sponsorship to only specified contracts and methods if needed. If no contract is whitelisted, then paymaster will facilitate all the contract interactions.
Whitelist a Smart Contract
​
Navigate to the Paymaster you have created, then click rules and contract. If this is the first time you are adding a smart contract the page will look like this:
Click on Add your First Contract and a side menu will show up asking you for details. Name your contract and provide an address. If your contract is verified the dashboard will automatically fetch the ABI for it, otherwise you can manually paste in the ABI yourself. You will then be able to choose any write methods to whitelist for sponsorship. In the example below I added the USDC contract on the Goerli testnet and chose to authorize the approve method for sponsorship.
Updating your Smart Contract
​
After adding your contract and whitelisting your methods you can make a few changes on the contract.
You can edit the contract to change the name or update which write methods you would like to authorize.
You can pause the contract to temporarily stop any sponsorships
You can delete the contract if you no longer need it on your Paymaster at all
Previous
Create a Paymaster
Next
Spending Limits
Whitelist a Smart Contract
Updating your Smart Contract
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Spending limits | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Spending Limits
Version: SDK V4 (latest)
On this page
Spending limits
This feature allows you to set limits to the gas usage. You can define global limits or per-user quotas, specifying either transaction count or total gas consumption.
Add a global limit
​
Navigate to the Paymaster you have created, then click Rules and Spending.
If this is the first time you are adding a limit the page will look like this:
Click on
Add limit
inside the Global Limit card and the new global limit modal will appear.
Inside the modal you will be presented with the option of choosing:
Threshold type (Gas Spend | Number of user operations)
Threshold value
Cycle duration (minimum 1 hour, maximum 23 hours)
After clicking
Create
the limit will be created.
Please note that whenever the limit policy is edited (duration/ threshold/ threshold type), the cycle is reset, and the new cycle starts from the moment of edit.
Pausing/Activating a limit will not reset the cycle.
Add a user limit
​
Click on
Add limit
inside the User Limit card and the new user limit modal will appear.
Both the global and the user limit modals are very similar and offer the same options.
Previous
Paymaster Rules
Next
Organizations
Add a global limit
Add a user limit
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Organization Overview | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
Organizations
Version: SDK V4 (latest)
On this page
Organization Overview
The organization feature is designed to enhance collaboration and streamline team management within your workspace.
This feature allows you to invite new team members to your organization and manage their access permissions. Whether you're looking to onboard new hires, collaborate with external partners, or reorganize teams, this feature was designed to provide you with a seamless management experience.
Inviting Team Members
​
Inviting colleagues to join your organization is straightforward. Follow these simple steps to send an invitation:
Click on the user settings dropdown and select 'Account Settings'.
Navigate to 'Team' page.
Click on '+ Invite User' button.
Enter the email address of the individuals you wish to invite.
Select the appropriate role from the predefined list to ensure each team member receives the access they require.
Send the invitation by clicking the 'Invite' button.
You can invite more team members at once by clicking '+ Add More' and following steps 4 to 6.
Once invited, team members will receive an email with a link to join the organization.
They will need to follow the link to set up their account and gain access to the resources permitted by their assigned role.
Role Permissions
​
Roles are defined as follows:
Admin
: Admins have full access to all settings and features, including the ability to invite new members, change any member’s role, manage permissions, and view and edit all projects and financial settings.
Editor
: Editors can access and modify all projects and settings except for team member management. This role is suited for team members who need to make substantial contributions to projects but do not need control over user roles and permissions.
Viewer
: Viewers have read-only access to all projects, meaning they cannot alter any project content. However, Viewers can deposit funds into the paymaster account, supporting financial operations without modifying project data.
Changing User Roles
​
Adjusting the roles of existing team members is a critical part of managing your organization's operations efficiently. Whether you need to upgrade a team member's access due to a change in responsibilities or downgrade access as part of a security protocol, our system provides a straightforward process for modifying user roles.
Steps to Change User Role:
Click on the user settings dropdown and select 'Account Settings'.
Navigate to 'Team' page.
Find the team member whose role you want to change.
Click on the user's current role displayed next to their status and select the new role you wish to assign to the user.
Removing Team Members
​
Removing a team member from your organization may be necessary due to changes in staffing, roles, or security policies. Our platform allows admins to delete members easily and securely to ensure that only authorized users have access to sensitive organizational data.
Click on the user settings dropdown and select 'Account Settings'.
Navigate to 'Team' page.
Find the team member you wish to remove.
Click on the Delete icon, located in the table row corresponding to the member you want to remove.
Removing Yourself from the Organization
​
There may come a time when you need to remove yourself from an organization, whether due to a change in job roles or leaving the company. Our system ensures that the organization continues to be managed effectively by requiring a smooth transition of administrative responsibilities before you can exit.
Prerequisites for Self-Removal:
​
Assign Another Admin:
Before you can remove yourself from the organization, ensure that at least one other team member is assigned and has accepted the role of Admin. This is crucial to maintain uninterrupted access to all settings and features within the organization.
Admin Acceptance:
The newly assigned Admin must accept their invitation and fully activate their account. This ensures that there is always at least one active Admin to manage the organization.
Steps to Remove Yourself:
​
Click on the user settings dropdown and select 'Account Settings'.
Navigate to 'Team' page.
Click on the Delete icon, located in the table row corresponding to your email.
Previous
Spending Limits
Next
APIs
Inviting Team Members
Role Permissions
Changing User Roles
Removing Team Members
Removing Yourself from the Organization
Prerequisites for Self-Removal:
Steps to Remove Yourself:
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Dashboard APIs | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Create a Paymaster
Paymaster Rules
Spending Limits
Organizations
APIs
Troubleshooting
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Dashboard
APIs
Version: SDK V4 (latest)
On this page
Dashboard APIs
Using these APIs allow you to perform various actions without the need to access the dashboard UI manually.
Auth Token
​
To obtain an authToken required in the header, you can generate one in your account settings page on the
biconomy dashboard
.
1. Get list of Paymasters:
​
GET Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
Responses
200 OK
{
"statusCode": 200,
"message": "DApp list fetched",
"data": [
{
"name": "setQuoteAmoy",
"chainId": 80002,
"apiKey": "lU3R_dRgt.22c06266-1faa-4c47-8477-e8eaacd90330"
},
{
"name": "setQuote",
"chainId": 137,
"apiKey": "rEEgKf5DS.a4e4f2c9-de7e-4a13-ac2d-6a9120714d61"
}
]
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
2. Create a new Paymaster:
​
POST Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
Body
Param
Type
Description
Required
name
string
Unique name of the DApp for a chain id
Required
type
string
Type of paymaster to be set up, in this case will be "HYBRID"
Required
chainId
number
Network on which the DApp exists
Required
version
string
String that represents the version of Paymaster to be used for the dApp
Required
200 OK
{
"statusCode": 200,
"message": "DApp registered successfully",
"data": {
"name": "setQuoteAmoy",
"chainId": 80002,
"apiKey": "vrTVKqTZI.7ea9dae1-9a06-4c17-a4fb-7728177b76d3" // apiKey is used to init biconomy instance to relay transactions for this Dapp
}
}
400 Bad Request
Paymaster Name Already Exists
{
"statusCode": 400,
"message": "paymaster_name_exists"
}
400 Bad Request
Chain Id not supported
{
"statusCode": 400,
"message": "Chain ID not supported"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token is required in the headers"
}
To manage the smart contracts associated with your DApp, we provide a set of endpoints that allow you to perform actions such as adding, updating, deleting, and retrieving a list of smart contracts. To access these endpoints, you will need to include the "apiKey" parameter in the header of your requests along with the "authToken".
The "apiKey" can be obtained in two ways:
When creating your DApp, you will receive an "apiKey" as part of the registration process.
Alternatively, if you already have a DApp registered, you can find the "apiKey" in the list API of the DApp.
3. Whitelist a Smart Contract:
​
POST Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/smart-contract
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
name
string
Unique name of smart contract
Required
address
string
Address of smart contract
Required
abi
string
Stringified ABI of smart contract
Required
whitelistedMethods
array of strings
List of method names of smart contract which are to be sponsored by DApp
Optional
Responses
200 OK
{
"statusCode": 200,
"message": "Smart contract registered successfully"
}
400 Bad Request
Smart Contract Already Exists
{
"statusCode": 400,
"message": "Smart contract address already exists"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
4. Get List of Smart Contracts:
​
GET Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/smart-contract
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
200 OK
{
"statusCode": 200,
"message": "Smart contract list fetched",
"data": [
{
"name": "Set Quote",
"address": "0xe31b0bcbda693bff2529f4a1d9f7e8f6d924c6ab",
"abi": "[ { \"inputs\": [ { \"internalType\": \"string\", \"name\": \"newQuote\", \"type\": \"string\" } ], \"name\": \"setQuote\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }, { \"inputs\": [], \"name\": \"admin\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"getQuote\", \"outputs\": [ { \"internalType\": \"string\", \"name\": \"currentQuote\", \"type\": \"string\" }, { \"internalType\": \"address\", \"name\": \"currentOwner\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"owner\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"quote\", \"outputs\": [ { \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" } ], \"stateMutability\": \"view\", \"type\": \"function\" } ]",
"whitelistedMethods": [
"setQuote"
],
"methods": [
"setQuote"
]
}
]
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
5. Update Smart Contract Whitelisted Methods:
​
PATCH Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/smart-contract
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
address
string
Smart contract address
Required
whitelistedMethods
array of strings
List of method names of smart contract which are to be sponsored by DApp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Smart contract updated",
"data": {
"name": "Set Quote",
"address": "0xe31b0bcbda693bff2529f4a1d9f7e8f6d924c6ab",
"abi": "[ { \"inputs\": [ { \"internalType\": \"string\", \"name\": \"newQuote\", \"type\": \"string\" } ], \"name\": \"setQuote\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }, { \"inputs\": [], \"name\": \"admin\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"getQuote\", \"outputs\": [ { \"internalType\": \"string\", \"name\": \"currentQuote\", \"type\": \"string\" }, { \"internalType\": \"address\", \"name\": \"currentOwner\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"owner\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"quote\", \"outputs\": [ { \"internalType\": \"string\", \"name\": \"\", \"type\": \"string\" } ], \"stateMutability\": \"view\", \"type\": \"function\" } ]",
"whitelistedMethods": [
"setQuote"
],
"methods": [
"setQuote"
]
}
}
400 Bad Request
Whitelisted methods must be an array
{
"statusCode": 400,
"message": "whitelistedMethods must be an array"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
404 Not Found
Usually, this occurs when incorrect apiKey is used or the address is not added
{
"statusCode": 400,
"message": "Smart contract not found"
}
6. Update Sponsorship Paymaster Funding Wallet:
​
It is a 3-step process.
​
1. Generate a message from biconomy servers, for the sponsorship paymaster.
​
GET Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/funding-message/{{paymasterId}}
Headers
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Funding message sent",
"data": {
"fundingMessage": "Timestamp: November 27, 2023, 5:05 PM\nWelcome to Biconomy! This request will connect your gas tank to our app. It will not trigger a blockchain transaction or incur any fees."
}
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
2. Sign the generated message using the private key of the EOA (Funding Wallet).
​
3. Send the request to biconomy to update the funding wallet address.
​
PATCH Request
https://paymaster-dashboard-backend.prod.biconomy.io//api/v2/public/sdk/paymaster
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
paymasterId
string
Sponsorship Paymaster Id
Required
type
string
Method Name.
Use "paymasterFundingId" here
Required
signature
string
Signature generated using private key of EOA
Required
address
string
Address of the EOA which is to be updated as funding wallet
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster updated successfully",
"data": {
"name": "testXXX",
"chainId": 80002,
"apiKey": "GwfDKydYq.2967f140-XXXX-4042-XXXX-76684f9XXXX",
"paymasterId": "e998530d-XXXX-451e-XXXX-cb6fXXXXef54"
}
}
400 Bad Request
This happens, when there is a signature mismatch, either because an older message is used to generate the signature, or EOA address mentioned in the request body, is not the address which signed the message.
{
"statusCode": 400,
"message": "Invalid signature"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
404 Not Found
Usually, this occurs when incorrect apiKey or authToken is used
{
"statusCode": 404,
"message": "User not found"
}
7. Delete Smart Contract
​
DELETE Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/smart-contract
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
address
string
Smart contract address
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Smart contract deleted"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
404 Not Found
{
"statusCode": 400,
"message": "Smart contract not found"
}
8. Add spending limit rule to a paymaster
​
POST Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
name
string
Unique Policy name
Required
policyType
string
Pass "PAYMASTER_SA_LIMIT" for spending limit
Required
policyData
object
Described below
Required
Policy Data
Param
Type
Description
Required
type
string
"PAYMASTER"(Global limit) / "SMART_ACCOUNT" (Individual User Limit)
Required
cycleDuration
object
eg.
{value:3, unit: "hour"}
,
{value:2, unit: "day"}
.
Currently only supported time units are "hour" and "day"
Required
threshold
number
Limit Value
Required
thresholdType
type
"COUNT" (Number of Userops) / "NATIVE_ASSET" (Gas Spend in native token, in eth)
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policy created successfully",
"data": {
"_id": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"name": "paymaster limit",
"policyType": "PAYMASTER_SA_LIMIT",
"organisationId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"paymasterId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"createdBy": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"chainId": 84532,
"active": true,
"policyData": {
"type": "PAYMASTER",
"startTimeInEpoch": 1709053430301,
"durationInMs": 10800000,
"cycleDuration": {
"value": 3,
"unit": "hour"
},
"threshold": 10,
"thresholdType": "COUNT"
}
}
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
9. Add a webhook rule to the paymaster
​
POST Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
name
string
Unique Policy name
Required
policyType
string
Pass "WEBHOOK" for webhook rule
Required
policyData
object
Described below
Required
Policy Data
Param
Type
Description
Required
url
string
Webhook URL which will be sent a POST request with the webhook data, and userOp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policy created successfully",
"data": {
"_id": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"name": "webhook rule",
"policyType": "WEBHOOK",
"organisationId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"paymasterId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"createdBy": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"chainId": 84532,
"active": true,
"policyData": {
"url": "https://www.google.com"
},
}
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
10. Add a "Wallet Deployment" rule to the paymaster
​
POST Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
name
string
Unique Policy name
Required
policyType
string
Pass "WALLET_DEPLOYMENT"
Required
policyData
object
Pass empty object (
{}
)
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policy created successfully",
"data": {
"_id": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"name": "wallet deployment rule",
"policyType": "WALLET_DEPLOYMENT",
"organisationId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"paymasterId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"createdBy": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"chainId": 84532,
"active": true,
"policyData": {
"operator": "walletDeployment"
},
}
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
11. Get all rules for a paymaster (spending limit, webhook, wallet deployment, whitelisted contracts)
​
GET Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policies found!",
"data": [
{
"_id": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"name": "paymaster spending limit",
"policyType": "PAYMASTER_SA_LIMIT",
"organisationId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"paymasterId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"createdBy": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"chainId": 84532,
"active": true,
"policyData": {
"type": "PAYMASTER",
"startTimeInEpoch": 1709053430301,
"durationInMs": 10800000,
"cycleDuration": {
"value": 3,
"unit": "hour"
},
"threshold": 10,
"thresholdType": "COUNT"
}
},
{
"_id": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"name": "wallet deployment rule",
"policyType": "WALLET_DEPLOYMENT",
"organisationId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"paymasterId": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"createdBy": "xxxxx-xxxx-xxxx-xxxx-xxxxx",
"chainId": 84532,
"active": true,
"policyData": {
"operator": "walletDeployment"
}
}
]
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
12. Update spending limit rule for a paymaster
​
PATCH Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy/limit/:policyId
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Body
Param
Type
Description
Required
name
string
New Policy name
cycleDuration
string
updated cycle duration
threshold
number
New spending limit threshold
thresholdType
string
New spending limit type
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Limit updated"
}
On a successful update, the cycle of the spending limit will be reset and the new limit will be applied from the time of the update.
{
"statusCode": 200,
"message": "Paymaster Limit updated"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
12. Pause a paymaster rule
​
PATCH Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy/deactivate/:policyId
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policy Deactivated!"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
13. Unpause a paymaster rule
​
PATCH Request
https://paymaster-dashboard-backend.prod.biconomy.io/api/v2/public/sdk/paymaster-policy/activate/:policyId
Parameters
Header
Param
Type
Description
Required
authToken
string
Token unique to every user account
Required
apiKey
string
API Key Associated with dApp
Required
Responses
200 OK
{
"statusCode": 200,
"message": "Paymaster Policy Activated!"
}
401 Unauthorized
{
"statusCode": 401,
"message": "Auth token and API key is required in the headers"
}
Previous
Organizations
Next
Troubleshooting
Auth Token
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Common Errors | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Common Errors
Polyfill Errors
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Troubleshooting
Common Errors
Version: SDK V4 (latest)
On this page
Common Errors
We are sorry to cause any inconvenience while interacting with biconomy SDK. We are trying our best to send meaningful error messages that can help you do quick fixes without interacting with any support channel. Some of the error messages are not in our control as we are using some standard contract ( e.g EntryPoint ) to provider gasless experience. Following are some standard error messages that can help you apply quick fixes and sort the issues.
tip
Ensure that you are using the bundler, paymaster, and RPC URL of the same blockchain.
Error
Description
AA21 didn’t pay prefund
Throws if your smart wallet does not have funds to send transaction. Send some native tokens in your smart wallet to be able to resolve the error.
AA23 reverted (or OOG)
Make sure the signature verification logic of the smart account is implemented correctly. Ensure you are using the same signer, you created the account with. If the error persists, try simulating
validateUserOp
method on entrypoint contract with the user operation on
tenderly
. Also ensure, if sender has sufficient native tokens to cover the User Operation's gas costs. If you are using paymaster to sponsor the transactions, ensure that the paymasterAndData field of the user operation is correctly set to enable proper handling of gas fees.
AA24 Signature error
Throws if the signature field of userOp is inaccurate. This could occur if any userOp field is altered after the userOp has been signed. Ensure that you are using the correct chain Id, entry point address and corresponding bundler URL.
AA10 sender already constructed
Throws if your smart wallet is already created but you are still sending
initcode
in userOp.
AA13 initCode failed or OOG
Throws if userOp doesn’t have enough
verificationGasLimit
to create smart account. you need to increase
verificationGasLimit
to be able to send transaction.
AA14 initCode must return sender
Throws if the factory contract that you are using to deploy smart account does not return smart account address. Or
sender
field in userOp does not have same address as factory contract is creating for you.
AA93 invalid paymasterAndData
Throws if
paymasterAndData
created by signing service is not valid.
AA95 out of gas
Throws if
callGasLimit
or
verificationGasLimit
is not correct for executing callData sent in userOp. Make sure
callGasLimit
and
verificationGasLimit
are not too high and use correct estimated values for preparing the userOp.
AA90 invalid beneficiary
Throws if the beneficiary address sent in userOp that is going to get sponsored transaction fee back is not valid.
AA31 paymaster deposit too low
Throws if the Paymaster you have created using dashboard does not have enough funds in its gas tank to sponsor transaction.
AA41 too little verificationGas
Throws if the userOp does not have enough
verificationGasLimit
to create smart account. you need to increase
verificationGasLimit
to be able to resolve this error.
AA33 reverted (or OOG)
Throws if the transaction you are sending is not valid or userOp does not have enough
verificationGasLimit
to be able to validate transaction. Try increasing
verificationGasLimit
or verify either the transaction you are making is valid to be able to resolve this error. In case of SPONSORED paymaster you might get this error due to insufficient token balance.
AA40 over verificationGasLimit
Throws when gas used in the verification step on chain, is more than the
verificationGasLimit
. Try increasing the
verificationGasLimit
value to be able to resolve this error.
AA51 prefund below actualGasCost
Throws because of 2 possible reasons: either your smart wallet does not have funds to send transaction or the Paymaster you have created using dashboard does not have enough funds in its gas tank to sponsor transaction.
AA34 signature error
Throws when the paymaster's signature is invalid. Check the format of the signature in paymasterAndData. Once the paymasterData is created, any changes to the userOp may lead to this error. In case you have passed the
calculateGasLimits
flag as true while creating the paymasterData, do update the gasLimits as mentioned
here
to avoid this error.
AA25 Invalid Account Nonce
Throws when the nonce is invalid. The user operation may be re-using an old nonce, or formatted the nonce incorrectly. If you are trying parallel transactions execution, refer to nonceOptions in
this
page for more details
No policies were set on the dashboard. Please set policies to allow gas sponsorship via paymasters
Throws if the contracts are not whitelisted using the dashboard to be able to sponsor transactions.
error in txn
Throws when there is internal server error from relayer side which can be due to multiple reasons. In this we would require the transacitonId from the user.
only allowed via delegateCall
Throws when trying to send native tokens directly to the Smart Account implementation.
Smart Account:: new Signatory address cannot be self
Throws when trying to set the Smart Account address as its own owner.
new Signatory address cannot be same as old one
Throws when trying to set owner with an address that is already an owner.
Address cannot be zero
Throws when trying to update to a zero address as implementation.
invalid tokenGasPriceFactor
Throws when token Gas Price factor provided is 0.
Invalid signatures length
Throws when the length of the signature provided in the Forward flow is less than 65.
Could not get network config values
Throws when we can’t find the provided network in the network config.
Exceeded maximum duration (30 sec) waiting to get receipt for userOpHash
This is a timeout error on bundler, If the error persists on a particular network, create a bundler instance by increasing the userOpReceiptMaxDurationIntervals as mentioned
here
. And pass this bundler to the
createSmartAccountClient
function
UserOperation reverted during execution phase
This error comes when the call data execution is failing, which is the call that the Entry Point makes to the Smart Account. A quick way to debug is to go on Tenderly and simulate the exact call data execution. To do that you can add the Smart Account address in the
Paste any address
box of Tenderly, then select the network which you are on. After that paste the
callData
from the userOp in the raw data input box and also edit the From address to be the Entry Point address. If the network you are on is not supported by Tenderly, one can use
eth_estimateGas
to capture the revert reason.
maxPriorityFeePerGas in userOp is lower than expected maxPriorityFeePerGas
This error indicates that the userOp sent to the bundler is a low paying userOp and won't be accepted in the bundler mempool. The way to fix this is to retry by building the userOp again. The value of maxPriorityFeePerGas should always be fetched from
biconomy_getGasFeeValues
or
eth_estimateUserOperationGas
.
maxFeePerGas in userOp is lower than expected maxFeePerGas
This error indicates that the userOp sent to the bundler is a low paying userOp and won't be accepted in the bundler mempool. The way to fix this is to retry by building the userOp again. The value of maxFeePerGas should always be fetched from
biconomy_getGasFeeValues
or
eth_estimateUserOperationGas
.
preVerificationGas in userOp is lower than expected preVerificationGas
This error indicates that the userOp sent to the bundler is a low paying userOp and won't be accepted in the bundler mempool. The way to fix this is to retry by building the userOp again. The value of preVerificationGas should always be fetched from
eth_estimateUserOperationGas
.
Custom Errors
​
Error Signature
Error Selector
Description
CallerIsNotAnEntryPoint
(address)
0xbb587b6e
Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account
HandlerCannotBeZero()
0xdd449f5f
Throws if zero address has been provided as Fallback Handler address
EntryPointCannotBeZero()
0x245d23e4
Throws if zero address has been provided as Entry Point address
MixedAuthFail
(address)
0x1141614a
Throws at mixedAuth when msg.sender is not an owner neither _self
TokenTransferFailed
(address,address,uint256)
0xc8776798
Throws if transfer of tokens failed. Arguments: token address, receiver address, amount.
OwnerCannotBeZero()
0x9b15e16f
Throws if trying to change an owner of a SmartAccount to the zero address
BaseImplementationCannotBeZero()
0x70204800
Throws if zero address has been provided as Base Implementation address
InvalidImplementation
(address)
0x0c760937
Throws if there is no code at implementationAddress
CallerIsNotOwner
(address)
0xd4ed9a17
Throws at onlyOwner when msg.sender is not an owner
CallerIsNotEntryPointOrOwner
(address)
0x65b7a78e
Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner
AlreadyInitialized
(address)
0x93360fbf
Throws if trying to initialize a Smart Account that has already been initialized
NotEnoughGasLeft
(uint256,uint256)
0xbbbb17a0
Throws if not enough gas is left at some point
CanNotEstimateGas
(uint256,uint256,bool)
0x830fc3f8
Throws if not able to estimate gas. It can happen when the amount of gas and its price are both zero and the transaction has failed to be executed
WrongContractSignatureFormat
(uint256,uint256,uint256)
0x71448bfe
Throws if contract signature is provided in the wrong format
WrongContractSignature
(bytes)
0x605d3489
Throws when isValidSignature for the contract signature and data hash return differs from EIP1271 Magic Value
InvalidSignature
(address,address)
0x42d750dc
Throws when the address that signed the data (restored from signature) differs from the expected signer
ExecutionFailed()
0xacfdb444
Throws when the transaction execution fails
TransferToZeroAddressAttempt()
0x9293b190
Throws when trying to transfer to the zero address
WrongBatchProvided
(uint256,uint256,uint256)
0x50605488
Throws when data for executeBatchCall provided in the wrong format (i.e. empty array or lengths mismatch)
ProxyDeploymentFailed
(address,uint256)
0x6d05b867
Throws when the Proxy (Smart Account) deployment attempt failed
ModulesAlreadyInitialized()
0xdf8cc4e3
Throws when trying to initialize the module manager that has already been initialized
ModulesSetupExecutionFailed()
0x65c74720
Throws when a delegatecall during module manager initialization has failed
ModuleCannotBeZeroOrSentinel
(address)
0xcadb248f
Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address
ModuleAlreadyEnabled
(address)
0xb29d4595
Throws when trying to enable a module that has already been enabled
ModuleAndPrevModuleMismatch
(address,address,address)
0xc40d496c
Throws when the module and previous module mismatch
ModuleNotEnabled
(address)
0x21ac7c5f
Throws when trying to execute a transaction from a module that is not enabled
CallerIsNotSelf
(address)
0x051e38cc
Throws when the caller is not address(this)
EntryPointCannotBeZero()
0x245d23e4
Throws when the Entry Point address provided is address(0)
VerifyingSignerCannotBeZero()
0x8fc6a931
Throws when the verifying signer address provided is address(0)
PaymasterIdCannotBeZero()
0xab9a38ca
Throws when the paymaster Id address provided is address(0)
DepositCanNotBeZero()
0x674c2ee2
Throws when 0 has been provided as the deposit amount
CanNotWithdrawToZeroAddress()
0x92bc9df3
Throws when trying to withdraw to address(0)
InsufficientBalance
(uint256,uint256)
0xcf479181
Throws when trying to withdraw more than the available balance
InvalidPaymasterSignatureLength
(uint256)
0xe4b52b17
Throws when the signature provided to the paymaster has an invalid length
Previous
Troubleshooting
Next
Polyfill Errors
Custom Errors
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.

Polyfill Errors | Biconomy
Skip to main content
Biconomy
Docs
Blog
Add Ons
SDK V4 (latest)
SDK V4 (latest)
SDK V3
Discussions
Dashboard
GitHub
Search
Overview
Quickstart
Tutorials
Smart Accounts
Paymaster
Bundler
Gas Estimations SDK
Modules
Dashboard
Troubleshooting
Common Errors
Polyfill Errors
Contract Addresses
Audits
FAQ
Supported Networks & Tokens
Troubleshooting
Polyfill Errors
Version: SDK V4 (latest)
On this page
Polyfill Errors
With many web3 tools you may run into Polyfill issues with error messages like 'crypto' not found, or 'buffer' not found. These are caused by Node JS Polyfills that are no longer included with Webpack after version 5. You can read more about the full details of this
here
.
To save you some time we have compiled a list of configurations and corresponding packages you will need to install in order to overcome some of these Polyfill errors for different Frontend Frameworks.
Next JS
​
Next JS is an easier framework to work with as it does not require any additional packages to be installed. You will however need to edit your
next.config.js
file to the following:
/**
@type
{
import
(
'next'
)
.
NextConfig
}
*/
const
nextConfig
=
{
reactStrictMode
:
true
,
webpack
:
(
config
,
{
isServer
}
)
=>
{
if
(
!
isServer
)
{
config
.
resolve
.
fallback
=
{
fs
:
false
,
net
:
false
,
tls
:
false
,
}
;
}
return
config
;
}
,
}
;
module
.
exports
=
nextConfig
;
React with Vite
​
There are several ways to build out a React application and one of them includes using Vite.
Below are the packages you will need to install before configuring your frontend:
yarn add @vitejs/plugin-react @esbuild-plugins/node-globals-polyfill process stream-browserify util rollup-plugin-polyfill-node
or
npm install yarn add @vitejs/plugin-react @esbuild-plugins/node-globals-polyfill process stream-browserify util rollup-plugin-polyfill-node
Below is the configuration needed in your
vite.config.ts
:
import
react
from
"@vitejs/plugin-react"
;
import
{
defineConfig
}
from
"vite"
;
export
default
defineConfig
(
{
plugins
:
[
react
(
)
]
,
optimizeDeps
:
{
esbuildOptions
:
{
define
:
{
global
:
"globalThis"
,
}
,
}
,
}
,
resolve
:
{
alias
:
{
process
:
"process/browser"
,
stream
:
"stream-browserify"
,
util
:
"util"
,
}
,
}
,
}
)
;
Vue JS
​
The following are packages you will need to install before configuring your frontend with Vue:
yarn add @esbuild-plugins/node-globals-polyfill stream-browserify util rollup-plugin-polyfill-node
or
npm install @esbuild-plugins/node-globals-polyfill stream-browserify util rollup-plugin-polyfill-node
Below is the configuration needed in your
vite.config.ts
import
vue
from
"@vitejs/plugin-vue"
;
import
vueJsx
from
"@vitejs/plugin-vue-jsx"
;
import
{
defineConfig
}
from
"vite"
;
export
default
defineConfig
(
{
plugins
:
[
vue
(
)
,
vueJsx
(
)
]
,
optimizeDeps
:
{
esbuildOptions
:
{
define
:
{
global
:
"globalThis"
,
}
,
}
,
}
,
resolve
:
{
alias
:
{
stream
:
"stream-browserify"
,
util
:
"util"
,
}
,
}
,
}
)
;
Create React App
​
While Create React App is no longer a recommended way of building out a React Project according to the official React documentation many projects may still be using it as a legacy dependency. In order to configure you will need to eject from Create React App and use
React App Rewired
.
Below are packages that will be helpful in getting this set up:
yarn add assert browserify-zlib c-kzg crypto-browserify https-browserify net os-browserify path-browserify react-app-rewired stream-browserify stream-http tls url
or
npm install assert browserify-zlib c-kzg crypto-browserify https-browserify net os-browserify path-browserify react-app-rewired stream-browserify stream-http tls url
Your config-overrides.js will need to look like this:
const
webpack
=
require
(
"webpack"
)
;
module
.
exports
=
function
override
(
config
)
{
const
fallback
=
config
.
resolve
.
fallback
||
{
}
;
Object
.
assign
(
fallback
,
{
fs
:
false
,
crypto
:
require
.
resolve
(
"crypto-browserify"
)
,
stream
:
require
.
resolve
(
"stream-browserify"
)
,
assert
:
require
.
resolve
(
"assert"
)
,
http
:
require
.
resolve
(
"stream-http"
)
,
os
:
require
.
resolve
(
"os-browserify"
)
,
https
:
require
.
resolve
(
"https-browserify"
)
,
url
:
require
.
resolve
(
"url"
)
,
zlib
:
require
.
resolve
(
"browserify-zlib"
)
,
path
:
require
.
resolve
(
"path-browserify"
)
,
"c-kzg"
:
require
.
resolve
(
"c-kzg"
)
,
"process/browser"
:
require
.
resolve
(
"process/browser"
)
,
}
)
;
config
.
resolve
.
fallback
=
fallback
;
config
.
plugins
=
(
config
.
plugins
||
[
]
)
.
concat
(
[
new
webpack
.
ProvidePlugin
(
{
process
:
"process/browser"
,
Buffer
:
[
"buffer"
,
"Buffer"
]
,
}
)
,
]
)
;
config
.
ignoreWarnings
=
[
/
Failed to parse source map
/
]
;
return
config
;
}
;
Previous
Common Errors
Next
Contract Addresses
Next JS
React with Vite
Vue JS
Create React App
Was this page helpful?
Yes
No
Docs
Quick Start
Smart Accounts
Paymaster
Bundler
Community
Github Discussion
Discord
Twitter
More
GitHub
Copyright © 2024 Biconomy Built with Docusaurus.